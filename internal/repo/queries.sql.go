// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package repo

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const addProjectMember = `-- name: AddProjectMember :exec
INSERT INTO project_members (project_id, user_id, role)
VALUES ($1, $2, $3)
ON CONFLICT (project_id, user_id) DO UPDATE SET role = $3
`

type AddProjectMemberParams struct {
	ProjectID uuid.UUID `json:"projectId"`
	UserID    uuid.UUID `json:"userId"`
	Role      string    `json:"role"`
}

func (q *Queries) AddProjectMember(ctx context.Context, arg AddProjectMemberParams) error {
	_, err := q.db.Exec(ctx, addProjectMember, arg.ProjectID, arg.UserID, arg.Role)
	return err
}

const checkProjectAccess = `-- name: CheckProjectAccess :one
SELECT EXISTS(
    SELECT 1 FROM projects p
    LEFT JOIN project_members pm ON p.id = pm.project_id
    WHERE p.id = $1 AND (p.owner_id = $2 OR pm.user_id = $2)
) as has_access
`

type CheckProjectAccessParams struct {
	ID      uuid.UUID `json:"id"`
	OwnerID uuid.UUID `json:"ownerId"`
}

func (q *Queries) CheckProjectAccess(ctx context.Context, arg CheckProjectAccessParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkProjectAccess, arg.ID, arg.OwnerID)
	var has_access bool
	err := row.Scan(&has_access)
	return has_access, err
}

const createMessage = `-- name: CreateMessage :one
INSERT INTO messages (project_id, sender_id, content, message_type, parent_message_id)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, project_id, sender_id, content, message_type, parent_message_id, created_at, updated_at
`

type CreateMessageParams struct {
	ProjectID       uuid.UUID   `json:"projectId"`
	SenderID        uuid.UUID   `json:"senderId"`
	Content         string      `json:"content"`
	MessageType     string      `json:"messageType"`
	ParentMessageID pgtype.UUID `json:"parentMessageId"`
}

func (q *Queries) CreateMessage(ctx context.Context, arg CreateMessageParams) (Message, error) {
	row := q.db.QueryRow(ctx, createMessage,
		arg.ProjectID,
		arg.SenderID,
		arg.Content,
		arg.MessageType,
		arg.ParentMessageID,
	)
	var i Message
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.SenderID,
		&i.Content,
		&i.MessageType,
		&i.ParentMessageID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createPasswordReset = `-- name: CreatePasswordReset :one
INSERT INTO password_resets (user_id, reset_token, expires_at)
VALUES ($1, $2, $3)
RETURNING id, user_id, reset_token, expires_at, created_at
`

type CreatePasswordResetParams struct {
	UserID     uuid.UUID `json:"userId"`
	ResetToken string    `json:"resetToken"`
	ExpiresAt  time.Time `json:"expiresAt"`
}

func (q *Queries) CreatePasswordReset(ctx context.Context, arg CreatePasswordResetParams) (PasswordReset, error) {
	row := q.db.QueryRow(ctx, createPasswordReset, arg.UserID, arg.ResetToken, arg.ExpiresAt)
	var i PasswordReset
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ResetToken,
		&i.ExpiresAt,
		&i.CreatedAt,
	)
	return i, err
}

const createProject = `-- name: CreateProject :one
INSERT INTO projects (owner_id, name, description)
VALUES ($1, $2, $3)
RETURNING id, owner_id, name, description, created_at, updated_at
`

type CreateProjectParams struct {
	OwnerID     uuid.UUID `json:"ownerId"`
	Name        string    `json:"name"`
	Description *string   `json:"description"`
}

func (q *Queries) CreateProject(ctx context.Context, arg CreateProjectParams) (Project, error) {
	row := q.db.QueryRow(ctx, createProject, arg.OwnerID, arg.Name, arg.Description)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.OwnerID,
		&i.Name,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createSprint = `-- name: CreateSprint :one
INSERT INTO sprints (project_id, name, description, start_date, end_date)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, project_id, name, description, start_date, end_date, is_completed, is_started, created_at, updated_at
`

type CreateSprintParams struct {
	ProjectID   uuid.UUID `json:"projectId"`
	Name        string    `json:"name"`
	Description *string   `json:"description"`
	StartDate   time.Time `json:"startDate"`
	EndDate     time.Time `json:"endDate"`
}

func (q *Queries) CreateSprint(ctx context.Context, arg CreateSprintParams) (Sprint, error) {
	row := q.db.QueryRow(ctx, createSprint,
		arg.ProjectID,
		arg.Name,
		arg.Description,
		arg.StartDate,
		arg.EndDate,
	)
	var i Sprint
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.Name,
		&i.Description,
		&i.StartDate,
		&i.EndDate,
		&i.IsCompleted,
		&i.IsStarted,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createTask = `-- name: CreateTask :one
INSERT INTO tasks (project_id, sprint_id, assignee_id, title, description, status)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, project_id, sprint_id, assignee_id, title, description, status, created_at, updated_at
`

type CreateTaskParams struct {
	ProjectID   uuid.UUID   `json:"projectId"`
	SprintID    pgtype.UUID `json:"sprintId"`
	AssigneeID  pgtype.UUID `json:"assigneeId"`
	Title       string      `json:"title"`
	Description *string     `json:"description"`
	Status      int32       `json:"status"`
}

func (q *Queries) CreateTask(ctx context.Context, arg CreateTaskParams) (Task, error) {
	row := q.db.QueryRow(ctx, createTask,
		arg.ProjectID,
		arg.SprintID,
		arg.AssigneeID,
		arg.Title,
		arg.Description,
		arg.Status,
	)
	var i Task
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.SprintID,
		&i.AssigneeID,
		&i.Title,
		&i.Description,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (username, email, password_h, first_name, last_name)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, username, email, first_name, last_name, active, avatar_url, created_at, updated_at
`

type CreateUserParams struct {
	Username  string `json:"username"`
	Email     string `json:"email"`
	PasswordH string `json:"passwordH"`
	FirstName string `json:"firstName"`
	LastName  string `json:"lastName"`
}

type CreateUserRow struct {
	ID        uuid.UUID `json:"id"`
	Username  string    `json:"username"`
	Email     string    `json:"email"`
	FirstName string    `json:"firstName"`
	LastName  string    `json:"lastName"`
	Active    bool      `json:"active"`
	AvatarUrl *string   `json:"avatarUrl"`
	CreatedAt time.Time `json:"createdAt"`
	UpdatedAt time.Time `json:"updatedAt"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (CreateUserRow, error) {
	row := q.db.QueryRow(ctx, createUser,
		arg.Username,
		arg.Email,
		arg.PasswordH,
		arg.FirstName,
		arg.LastName,
	)
	var i CreateUserRow
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.FirstName,
		&i.LastName,
		&i.Active,
		&i.AvatarUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deactivateUser = `-- name: DeactivateUser :exec
UPDATE users
SET active = false, updated_at = now()
WHERE id = $1
`

func (q *Queries) DeactivateUser(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deactivateUser, id)
	return err
}

const deleteExpiredPasswordResets = `-- name: DeleteExpiredPasswordResets :exec
DELETE FROM password_resets WHERE expires_at < now()
`

func (q *Queries) DeleteExpiredPasswordResets(ctx context.Context) error {
	_, err := q.db.Exec(ctx, deleteExpiredPasswordResets)
	return err
}

const deleteMessage = `-- name: DeleteMessage :exec
DELETE FROM messages WHERE id = $1
`

func (q *Queries) DeleteMessage(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteMessage, id)
	return err
}

const deletePasswordReset = `-- name: DeletePasswordReset :exec
DELETE FROM password_resets WHERE reset_token = $1
`

func (q *Queries) DeletePasswordReset(ctx context.Context, resetToken string) error {
	_, err := q.db.Exec(ctx, deletePasswordReset, resetToken)
	return err
}

const deleteProject = `-- name: DeleteProject :exec
DELETE FROM projects WHERE id = $1
`

func (q *Queries) DeleteProject(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteProject, id)
	return err
}

const deleteSprint = `-- name: DeleteSprint :exec
DELETE FROM sprints WHERE id = $1
`

func (q *Queries) DeleteSprint(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteSprint, id)
	return err
}

const deleteTask = `-- name: DeleteTask :exec
DELETE FROM tasks WHERE id = $1
`

func (q *Queries) DeleteTask(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteTask, id)
	return err
}

const getMessageByID = `-- name: GetMessageByID :one
SELECT m.id, m.project_id, m.sender_id, m.content, m.message_type, m.parent_message_id, m.created_at, m.updated_at,
       u.username as sender_username, u.first_name as sender_first_name, u.last_name as sender_last_name, u.avatar_url as sender_avatar_url
FROM messages m
JOIN users u ON m.sender_id = u.id
WHERE m.id = $1
`

type GetMessageByIDRow struct {
	ID              uuid.UUID   `json:"id"`
	ProjectID       uuid.UUID   `json:"projectId"`
	SenderID        uuid.UUID   `json:"senderId"`
	Content         string      `json:"content"`
	MessageType     string      `json:"messageType"`
	ParentMessageID pgtype.UUID `json:"parentMessageId"`
	CreatedAt       time.Time   `json:"createdAt"`
	UpdatedAt       time.Time   `json:"updatedAt"`
	SenderUsername  string      `json:"senderUsername"`
	SenderFirstName string      `json:"senderFirstName"`
	SenderLastName  string      `json:"senderLastName"`
	SenderAvatarUrl *string     `json:"senderAvatarUrl"`
}

func (q *Queries) GetMessageByID(ctx context.Context, id uuid.UUID) (GetMessageByIDRow, error) {
	row := q.db.QueryRow(ctx, getMessageByID, id)
	var i GetMessageByIDRow
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.SenderID,
		&i.Content,
		&i.MessageType,
		&i.ParentMessageID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.SenderUsername,
		&i.SenderFirstName,
		&i.SenderLastName,
		&i.SenderAvatarUrl,
	)
	return i, err
}

const getPasswordResetByToken = `-- name: GetPasswordResetByToken :one
SELECT pr.id, pr.user_id, pr.reset_token, pr.expires_at, pr.created_at,
       u.username, u.email, u.first_name, u.last_name
FROM password_resets pr
JOIN users u ON pr.user_id = u.id
WHERE pr.reset_token = $1
`

type GetPasswordResetByTokenRow struct {
	ID         int32     `json:"id"`
	UserID     uuid.UUID `json:"userId"`
	ResetToken string    `json:"resetToken"`
	ExpiresAt  time.Time `json:"expiresAt"`
	CreatedAt  time.Time `json:"createdAt"`
	Username   string    `json:"username"`
	Email      string    `json:"email"`
	FirstName  string    `json:"firstName"`
	LastName   string    `json:"lastName"`
}

func (q *Queries) GetPasswordResetByToken(ctx context.Context, resetToken string) (GetPasswordResetByTokenRow, error) {
	row := q.db.QueryRow(ctx, getPasswordResetByToken, resetToken)
	var i GetPasswordResetByTokenRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ResetToken,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.Username,
		&i.Email,
		&i.FirstName,
		&i.LastName,
	)
	return i, err
}

const getProjectByID = `-- name: GetProjectByID :one
SELECT p.id, p.owner_id, p.name, p.description, p.created_at, p.updated_at,
       u.id as owner_id, u.username as owner_username, u.email as owner_email,
       u.first_name as owner_first_name, u.last_name as owner_last_name
FROM projects p
JOIN users u ON p.owner_id = u.id
WHERE p.id = $1
`

type GetProjectByIDRow struct {
	ID             uuid.UUID `json:"id"`
	OwnerID        uuid.UUID `json:"ownerId"`
	Name           string    `json:"name"`
	Description    *string   `json:"description"`
	CreatedAt      time.Time `json:"createdAt"`
	UpdatedAt      time.Time `json:"updatedAt"`
	OwnerID_2      uuid.UUID `json:"ownerId2"`
	OwnerUsername  string    `json:"ownerUsername"`
	OwnerEmail     string    `json:"ownerEmail"`
	OwnerFirstName string    `json:"ownerFirstName"`
	OwnerLastName  string    `json:"ownerLastName"`
}

func (q *Queries) GetProjectByID(ctx context.Context, id uuid.UUID) (GetProjectByIDRow, error) {
	row := q.db.QueryRow(ctx, getProjectByID, id)
	var i GetProjectByIDRow
	err := row.Scan(
		&i.ID,
		&i.OwnerID,
		&i.Name,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.OwnerID_2,
		&i.OwnerUsername,
		&i.OwnerEmail,
		&i.OwnerFirstName,
		&i.OwnerLastName,
	)
	return i, err
}

const getProjectMembers = `-- name: GetProjectMembers :many
SELECT pm.project_id, pm.user_id, pm.role, pm.joined_at,
       u.username, u.email, u.first_name, u.last_name, u.avatar_url
FROM project_members pm
JOIN users u ON pm.user_id = u.id
WHERE pm.project_id = $1
ORDER BY pm.joined_at
`

type GetProjectMembersRow struct {
	ProjectID uuid.UUID `json:"projectId"`
	UserID    uuid.UUID `json:"userId"`
	Role      string    `json:"role"`
	JoinedAt  time.Time `json:"joinedAt"`
	Username  string    `json:"username"`
	Email     string    `json:"email"`
	FirstName string    `json:"firstName"`
	LastName  string    `json:"lastName"`
	AvatarUrl *string   `json:"avatarUrl"`
}

func (q *Queries) GetProjectMembers(ctx context.Context, projectID uuid.UUID) ([]GetProjectMembersRow, error) {
	rows, err := q.db.Query(ctx, getProjectMembers, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProjectMembersRow
	for rows.Next() {
		var i GetProjectMembersRow
		if err := rows.Scan(
			&i.ProjectID,
			&i.UserID,
			&i.Role,
			&i.JoinedAt,
			&i.Username,
			&i.Email,
			&i.FirstName,
			&i.LastName,
			&i.AvatarUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSprintByID = `-- name: GetSprintByID :one
SELECT s.id, s.project_id, s.name, s.description, s.start_date, s.end_date, s.is_completed, s.is_started, s.created_at, s.updated_at,
       p.owner_id, u.username as owner_username, u.email as owner_email, u.first_name as owner_first_name, u.last_name as owner_last_name
FROM sprints s
JOIN projects p ON s.project_id = p.id
JOIN users u ON p.owner_id = u.id
WHERE s.id = $1
`

type GetSprintByIDRow struct {
	ID             uuid.UUID `json:"id"`
	ProjectID      uuid.UUID `json:"projectId"`
	Name           string    `json:"name"`
	Description    *string   `json:"description"`
	StartDate      time.Time `json:"startDate"`
	EndDate        time.Time `json:"endDate"`
	IsCompleted    bool      `json:"isCompleted"`
	IsStarted      bool      `json:"isStarted"`
	CreatedAt      time.Time `json:"createdAt"`
	UpdatedAt      time.Time `json:"updatedAt"`
	OwnerID        uuid.UUID `json:"ownerId"`
	OwnerUsername  string    `json:"ownerUsername"`
	OwnerEmail     string    `json:"ownerEmail"`
	OwnerFirstName string    `json:"ownerFirstName"`
	OwnerLastName  string    `json:"ownerLastName"`
}

func (q *Queries) GetSprintByID(ctx context.Context, id uuid.UUID) (GetSprintByIDRow, error) {
	row := q.db.QueryRow(ctx, getSprintByID, id)
	var i GetSprintByIDRow
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.Name,
		&i.Description,
		&i.StartDate,
		&i.EndDate,
		&i.IsCompleted,
		&i.IsStarted,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.OwnerID,
		&i.OwnerUsername,
		&i.OwnerEmail,
		&i.OwnerFirstName,
		&i.OwnerLastName,
	)
	return i, err
}

const getTaskByID = `-- name: GetTaskByID :one
SELECT t.id, t.project_id, t.sprint_id, t.assignee_id, t.title, t.description, t.status, t.created_at, t.updated_at,
       u.username as assignee_username, u.first_name as assignee_first_name, u.last_name as assignee_last_name,
       p.owner_id, owner.username as owner_username, owner.email as owner_email, owner.first_name as owner_first_name, owner.last_name as owner_last_name
FROM tasks t
LEFT JOIN users u ON t.assignee_id = u.id
JOIN projects p ON t.project_id = p.id
JOIN users owner ON p.owner_id = owner.id
WHERE t.id = $1
`

type GetTaskByIDRow struct {
	ID                uuid.UUID   `json:"id"`
	ProjectID         uuid.UUID   `json:"projectId"`
	SprintID          pgtype.UUID `json:"sprintId"`
	AssigneeID        pgtype.UUID `json:"assigneeId"`
	Title             string      `json:"title"`
	Description       *string     `json:"description"`
	Status            int32       `json:"status"`
	CreatedAt         time.Time   `json:"createdAt"`
	UpdatedAt         time.Time   `json:"updatedAt"`
	AssigneeUsername  *string     `json:"assigneeUsername"`
	AssigneeFirstName *string     `json:"assigneeFirstName"`
	AssigneeLastName  *string     `json:"assigneeLastName"`
	OwnerID           uuid.UUID   `json:"ownerId"`
	OwnerUsername     string      `json:"ownerUsername"`
	OwnerEmail        string      `json:"ownerEmail"`
	OwnerFirstName    string      `json:"ownerFirstName"`
	OwnerLastName     string      `json:"ownerLastName"`
}

func (q *Queries) GetTaskByID(ctx context.Context, id uuid.UUID) (GetTaskByIDRow, error) {
	row := q.db.QueryRow(ctx, getTaskByID, id)
	var i GetTaskByIDRow
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.SprintID,
		&i.AssigneeID,
		&i.Title,
		&i.Description,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.AssigneeUsername,
		&i.AssigneeFirstName,
		&i.AssigneeLastName,
		&i.OwnerID,
		&i.OwnerUsername,
		&i.OwnerEmail,
		&i.OwnerFirstName,
		&i.OwnerLastName,
	)
	return i, err
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, username, email, password_h, first_name, last_name, active, avatar_url, created_at, updated_at
FROM users
WHERE lower(email) = lower($1)
`

func (q *Queries) GetUserByEmail(ctx context.Context, lower string) (User, error) {
	row := q.db.QueryRow(ctx, getUserByEmail, lower)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.PasswordH,
		&i.FirstName,
		&i.LastName,
		&i.Active,
		&i.AvatarUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT id, username, email, first_name, last_name, active, avatar_url, created_at, updated_at
FROM users
WHERE id = $1
`

type GetUserByIDRow struct {
	ID        uuid.UUID `json:"id"`
	Username  string    `json:"username"`
	Email     string    `json:"email"`
	FirstName string    `json:"firstName"`
	LastName  string    `json:"lastName"`
	Active    bool      `json:"active"`
	AvatarUrl *string   `json:"avatarUrl"`
	CreatedAt time.Time `json:"createdAt"`
	UpdatedAt time.Time `json:"updatedAt"`
}

func (q *Queries) GetUserByID(ctx context.Context, id uuid.UUID) (GetUserByIDRow, error) {
	row := q.db.QueryRow(ctx, getUserByID, id)
	var i GetUserByIDRow
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.FirstName,
		&i.LastName,
		&i.Active,
		&i.AvatarUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserByUsername = `-- name: GetUserByUsername :one
SELECT id, username, email, password_h, first_name, last_name, active, avatar_url, created_at, updated_at
FROM users
WHERE lower(username) = lower($1)
`

func (q *Queries) GetUserByUsername(ctx context.Context, lower string) (User, error) {
	row := q.db.QueryRow(ctx, getUserByUsername, lower)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.PasswordH,
		&i.FirstName,
		&i.LastName,
		&i.Active,
		&i.AvatarUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listMessagesByProject = `-- name: ListMessagesByProject :many
SELECT m.id, m.project_id, m.sender_id, m.content, m.message_type, m.parent_message_id, m.created_at, m.updated_at,
       u.username as sender_username, u.first_name as sender_first_name, u.last_name as sender_last_name, u.avatar_url as sender_avatar_url
FROM messages m
JOIN users u ON m.sender_id = u.id
WHERE m.project_id = $1
ORDER BY m.created_at DESC
LIMIT $2 OFFSET $3
`

type ListMessagesByProjectParams struct {
	ProjectID uuid.UUID `json:"projectId"`
	Limit     int32     `json:"limit"`
	Offset    int32     `json:"offset"`
}

type ListMessagesByProjectRow struct {
	ID              uuid.UUID   `json:"id"`
	ProjectID       uuid.UUID   `json:"projectId"`
	SenderID        uuid.UUID   `json:"senderId"`
	Content         string      `json:"content"`
	MessageType     string      `json:"messageType"`
	ParentMessageID pgtype.UUID `json:"parentMessageId"`
	CreatedAt       time.Time   `json:"createdAt"`
	UpdatedAt       time.Time   `json:"updatedAt"`
	SenderUsername  string      `json:"senderUsername"`
	SenderFirstName string      `json:"senderFirstName"`
	SenderLastName  string      `json:"senderLastName"`
	SenderAvatarUrl *string     `json:"senderAvatarUrl"`
}

func (q *Queries) ListMessagesByProject(ctx context.Context, arg ListMessagesByProjectParams) ([]ListMessagesByProjectRow, error) {
	rows, err := q.db.Query(ctx, listMessagesByProject, arg.ProjectID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListMessagesByProjectRow
	for rows.Next() {
		var i ListMessagesByProjectRow
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.SenderID,
			&i.Content,
			&i.MessageType,
			&i.ParentMessageID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SenderUsername,
			&i.SenderFirstName,
			&i.SenderLastName,
			&i.SenderAvatarUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMessagesByProjectAfter = `-- name: ListMessagesByProjectAfter :many
SELECT m.id, m.project_id, m.sender_id, m.content, m.message_type, m.parent_message_id, m.created_at, m.updated_at,
       u.username as sender_username, u.first_name as sender_first_name, u.last_name as sender_last_name, u.avatar_url as sender_avatar_url
FROM messages m
JOIN users u ON m.sender_id = u.id
WHERE m.project_id = $1 AND m.id > $2
ORDER BY m.created_at ASC
LIMIT $3
`

type ListMessagesByProjectAfterParams struct {
	ProjectID uuid.UUID `json:"projectId"`
	ID        uuid.UUID `json:"id"`
	Limit     int32     `json:"limit"`
}

type ListMessagesByProjectAfterRow struct {
	ID              uuid.UUID   `json:"id"`
	ProjectID       uuid.UUID   `json:"projectId"`
	SenderID        uuid.UUID   `json:"senderId"`
	Content         string      `json:"content"`
	MessageType     string      `json:"messageType"`
	ParentMessageID pgtype.UUID `json:"parentMessageId"`
	CreatedAt       time.Time   `json:"createdAt"`
	UpdatedAt       time.Time   `json:"updatedAt"`
	SenderUsername  string      `json:"senderUsername"`
	SenderFirstName string      `json:"senderFirstName"`
	SenderLastName  string      `json:"senderLastName"`
	SenderAvatarUrl *string     `json:"senderAvatarUrl"`
}

func (q *Queries) ListMessagesByProjectAfter(ctx context.Context, arg ListMessagesByProjectAfterParams) ([]ListMessagesByProjectAfterRow, error) {
	rows, err := q.db.Query(ctx, listMessagesByProjectAfter, arg.ProjectID, arg.ID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListMessagesByProjectAfterRow
	for rows.Next() {
		var i ListMessagesByProjectAfterRow
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.SenderID,
			&i.Content,
			&i.MessageType,
			&i.ParentMessageID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SenderUsername,
			&i.SenderFirstName,
			&i.SenderLastName,
			&i.SenderAvatarUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProjectMembers = `-- name: ListProjectMembers :many
SELECT u.id, u.username, u.email, u.first_name, u.last_name, p.created_at as joined_at, 'owner' as role
FROM projects p
JOIN users u ON p.owner_id = u.id
WHERE p.id = $1

UNION ALL

SELECT u.id, u.username, u.email, u.first_name, u.last_name, pm.joined_at, pm.role
FROM project_members pm
JOIN users u ON pm.user_id = u.id
WHERE pm.project_id = $1

ORDER BY joined_at
`

type ListProjectMembersRow struct {
	ID        uuid.UUID `json:"id"`
	Username  string    `json:"username"`
	Email     string    `json:"email"`
	FirstName string    `json:"firstName"`
	LastName  string    `json:"lastName"`
	JoinedAt  time.Time `json:"joinedAt"`
	Role      string    `json:"role"`
}

// Get project owner as a member
// Get additional project members
func (q *Queries) ListProjectMembers(ctx context.Context, id uuid.UUID) ([]ListProjectMembersRow, error) {
	rows, err := q.db.Query(ctx, listProjectMembers, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListProjectMembersRow
	for rows.Next() {
		var i ListProjectMembersRow
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.Email,
			&i.FirstName,
			&i.LastName,
			&i.JoinedAt,
			&i.Role,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProjectsByUser = `-- name: ListProjectsByUser :many
SELECT p.id, p.owner_id, p.name, p.description, p.created_at, p.updated_at,
       u.id as owner_id, u.username as owner_username, u.email as owner_email,
       u.first_name as owner_first_name, u.last_name as owner_last_name
FROM projects p
JOIN users u ON p.owner_id = u.id
LEFT JOIN project_members pm ON p.id = pm.project_id
WHERE p.owner_id = $1 OR pm.user_id = $1
ORDER BY p.created_at DESC
LIMIT $2 OFFSET $3
`

type ListProjectsByUserParams struct {
	OwnerID uuid.UUID `json:"ownerId"`
	Limit   int32     `json:"limit"`
	Offset  int32     `json:"offset"`
}

type ListProjectsByUserRow struct {
	ID             uuid.UUID `json:"id"`
	OwnerID        uuid.UUID `json:"ownerId"`
	Name           string    `json:"name"`
	Description    *string   `json:"description"`
	CreatedAt      time.Time `json:"createdAt"`
	UpdatedAt      time.Time `json:"updatedAt"`
	OwnerID_2      uuid.UUID `json:"ownerId2"`
	OwnerUsername  string    `json:"ownerUsername"`
	OwnerEmail     string    `json:"ownerEmail"`
	OwnerFirstName string    `json:"ownerFirstName"`
	OwnerLastName  string    `json:"ownerLastName"`
}

func (q *Queries) ListProjectsByUser(ctx context.Context, arg ListProjectsByUserParams) ([]ListProjectsByUserRow, error) {
	rows, err := q.db.Query(ctx, listProjectsByUser, arg.OwnerID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListProjectsByUserRow
	for rows.Next() {
		var i ListProjectsByUserRow
		if err := rows.Scan(
			&i.ID,
			&i.OwnerID,
			&i.Name,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.OwnerID_2,
			&i.OwnerUsername,
			&i.OwnerEmail,
			&i.OwnerFirstName,
			&i.OwnerLastName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSprintsByProject = `-- name: ListSprintsByProject :many
SELECT s.id, s.project_id, s.name, s.description, s.start_date, s.end_date, s.is_completed, s.is_started, s.created_at, s.updated_at,
       p.owner_id, u.username as owner_username, u.email as owner_email, u.first_name as owner_first_name, u.last_name as owner_last_name
FROM sprints s
JOIN projects p ON s.project_id = p.id
JOIN users u ON p.owner_id = u.id
WHERE s.project_id = $1
ORDER BY s.start_date DESC
LIMIT $2 OFFSET $3
`

type ListSprintsByProjectParams struct {
	ProjectID uuid.UUID `json:"projectId"`
	Limit     int32     `json:"limit"`
	Offset    int32     `json:"offset"`
}

type ListSprintsByProjectRow struct {
	ID             uuid.UUID `json:"id"`
	ProjectID      uuid.UUID `json:"projectId"`
	Name           string    `json:"name"`
	Description    *string   `json:"description"`
	StartDate      time.Time `json:"startDate"`
	EndDate        time.Time `json:"endDate"`
	IsCompleted    bool      `json:"isCompleted"`
	IsStarted      bool      `json:"isStarted"`
	CreatedAt      time.Time `json:"createdAt"`
	UpdatedAt      time.Time `json:"updatedAt"`
	OwnerID        uuid.UUID `json:"ownerId"`
	OwnerUsername  string    `json:"ownerUsername"`
	OwnerEmail     string    `json:"ownerEmail"`
	OwnerFirstName string    `json:"ownerFirstName"`
	OwnerLastName  string    `json:"ownerLastName"`
}

func (q *Queries) ListSprintsByProject(ctx context.Context, arg ListSprintsByProjectParams) ([]ListSprintsByProjectRow, error) {
	rows, err := q.db.Query(ctx, listSprintsByProject, arg.ProjectID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListSprintsByProjectRow
	for rows.Next() {
		var i ListSprintsByProjectRow
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.Name,
			&i.Description,
			&i.StartDate,
			&i.EndDate,
			&i.IsCompleted,
			&i.IsStarted,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.OwnerID,
			&i.OwnerUsername,
			&i.OwnerEmail,
			&i.OwnerFirstName,
			&i.OwnerLastName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTasksByProject = `-- name: ListTasksByProject :many
SELECT t.id, t.project_id, t.sprint_id, t.assignee_id, t.title, t.description, t.status, t.created_at, t.updated_at,
       u.username as assignee_username, u.first_name as assignee_first_name, u.last_name as assignee_last_name,
       p.owner_id, owner.username as owner_username, owner.email as owner_email, owner.first_name as owner_first_name, owner.last_name as owner_last_name
FROM tasks t
LEFT JOIN users u ON t.assignee_id = u.id
JOIN projects p ON t.project_id = p.id
JOIN users owner ON p.owner_id = owner.id
WHERE t.project_id = $1
ORDER BY t.created_at DESC
LIMIT $2 OFFSET $3
`

type ListTasksByProjectParams struct {
	ProjectID uuid.UUID `json:"projectId"`
	Limit     int32     `json:"limit"`
	Offset    int32     `json:"offset"`
}

type ListTasksByProjectRow struct {
	ID                uuid.UUID   `json:"id"`
	ProjectID         uuid.UUID   `json:"projectId"`
	SprintID          pgtype.UUID `json:"sprintId"`
	AssigneeID        pgtype.UUID `json:"assigneeId"`
	Title             string      `json:"title"`
	Description       *string     `json:"description"`
	Status            int32       `json:"status"`
	CreatedAt         time.Time   `json:"createdAt"`
	UpdatedAt         time.Time   `json:"updatedAt"`
	AssigneeUsername  *string     `json:"assigneeUsername"`
	AssigneeFirstName *string     `json:"assigneeFirstName"`
	AssigneeLastName  *string     `json:"assigneeLastName"`
	OwnerID           uuid.UUID   `json:"ownerId"`
	OwnerUsername     string      `json:"ownerUsername"`
	OwnerEmail        string      `json:"ownerEmail"`
	OwnerFirstName    string      `json:"ownerFirstName"`
	OwnerLastName     string      `json:"ownerLastName"`
}

func (q *Queries) ListTasksByProject(ctx context.Context, arg ListTasksByProjectParams) ([]ListTasksByProjectRow, error) {
	rows, err := q.db.Query(ctx, listTasksByProject, arg.ProjectID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListTasksByProjectRow
	for rows.Next() {
		var i ListTasksByProjectRow
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.SprintID,
			&i.AssigneeID,
			&i.Title,
			&i.Description,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.AssigneeUsername,
			&i.AssigneeFirstName,
			&i.AssigneeLastName,
			&i.OwnerID,
			&i.OwnerUsername,
			&i.OwnerEmail,
			&i.OwnerFirstName,
			&i.OwnerLastName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTasksBySprint = `-- name: ListTasksBySprint :many
SELECT t.id, t.project_id, t.sprint_id, t.assignee_id, t.title, t.description, t.status, t.created_at, t.updated_at,
       u.username as assignee_username, u.first_name as assignee_first_name, u.last_name as assignee_last_name,
       p.owner_id, owner.username as owner_username, owner.email as owner_email, owner.first_name as owner_first_name, owner.last_name as owner_last_name
FROM tasks t
LEFT JOIN users u ON t.assignee_id = u.id
JOIN projects p ON t.project_id = p.id
JOIN users owner ON p.owner_id = owner.id
WHERE t.sprint_id = $1
ORDER BY t.created_at DESC
LIMIT $2 OFFSET $3
`

type ListTasksBySprintParams struct {
	SprintID pgtype.UUID `json:"sprintId"`
	Limit    int32       `json:"limit"`
	Offset   int32       `json:"offset"`
}

type ListTasksBySprintRow struct {
	ID                uuid.UUID   `json:"id"`
	ProjectID         uuid.UUID   `json:"projectId"`
	SprintID          pgtype.UUID `json:"sprintId"`
	AssigneeID        pgtype.UUID `json:"assigneeId"`
	Title             string      `json:"title"`
	Description       *string     `json:"description"`
	Status            int32       `json:"status"`
	CreatedAt         time.Time   `json:"createdAt"`
	UpdatedAt         time.Time   `json:"updatedAt"`
	AssigneeUsername  *string     `json:"assigneeUsername"`
	AssigneeFirstName *string     `json:"assigneeFirstName"`
	AssigneeLastName  *string     `json:"assigneeLastName"`
	OwnerID           uuid.UUID   `json:"ownerId"`
	OwnerUsername     string      `json:"ownerUsername"`
	OwnerEmail        string      `json:"ownerEmail"`
	OwnerFirstName    string      `json:"ownerFirstName"`
	OwnerLastName     string      `json:"ownerLastName"`
}

func (q *Queries) ListTasksBySprint(ctx context.Context, arg ListTasksBySprintParams) ([]ListTasksBySprintRow, error) {
	rows, err := q.db.Query(ctx, listTasksBySprint, arg.SprintID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListTasksBySprintRow
	for rows.Next() {
		var i ListTasksBySprintRow
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.SprintID,
			&i.AssigneeID,
			&i.Title,
			&i.Description,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.AssigneeUsername,
			&i.AssigneeFirstName,
			&i.AssigneeLastName,
			&i.OwnerID,
			&i.OwnerUsername,
			&i.OwnerEmail,
			&i.OwnerFirstName,
			&i.OwnerLastName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUsers = `-- name: ListUsers :many
SELECT id, username, email, first_name, last_name, active, avatar_url, created_at, updated_at
FROM users
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type ListUsersParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListUsersRow struct {
	ID        uuid.UUID `json:"id"`
	Username  string    `json:"username"`
	Email     string    `json:"email"`
	FirstName string    `json:"firstName"`
	LastName  string    `json:"lastName"`
	Active    bool      `json:"active"`
	AvatarUrl *string   `json:"avatarUrl"`
	CreatedAt time.Time `json:"createdAt"`
	UpdatedAt time.Time `json:"updatedAt"`
}

func (q *Queries) ListUsers(ctx context.Context, arg ListUsersParams) ([]ListUsersRow, error) {
	rows, err := q.db.Query(ctx, listUsers, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListUsersRow
	for rows.Next() {
		var i ListUsersRow
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.Email,
			&i.FirstName,
			&i.LastName,
			&i.Active,
			&i.AvatarUrl,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeProjectMember = `-- name: RemoveProjectMember :exec
DELETE FROM project_members WHERE project_id = $1 AND user_id = $2
`

type RemoveProjectMemberParams struct {
	ProjectID uuid.UUID `json:"projectId"`
	UserID    uuid.UUID `json:"userId"`
}

func (q *Queries) RemoveProjectMember(ctx context.Context, arg RemoveProjectMemberParams) error {
	_, err := q.db.Exec(ctx, removeProjectMember, arg.ProjectID, arg.UserID)
	return err
}

const updateMessage = `-- name: UpdateMessage :one
UPDATE messages
SET content = $2, updated_at = now()
WHERE id = $1
RETURNING id, project_id, sender_id, content, message_type, parent_message_id, created_at, updated_at
`

type UpdateMessageParams struct {
	ID      uuid.UUID `json:"id"`
	Content string    `json:"content"`
}

func (q *Queries) UpdateMessage(ctx context.Context, arg UpdateMessageParams) (Message, error) {
	row := q.db.QueryRow(ctx, updateMessage, arg.ID, arg.Content)
	var i Message
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.SenderID,
		&i.Content,
		&i.MessageType,
		&i.ParentMessageID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateProject = `-- name: UpdateProject :one
UPDATE projects
SET name = $2, description = $3, updated_at = now()
WHERE id = $1
RETURNING id, owner_id, name, description, created_at, updated_at
`

type UpdateProjectParams struct {
	ID          uuid.UUID `json:"id"`
	Name        string    `json:"name"`
	Description *string   `json:"description"`
}

func (q *Queries) UpdateProject(ctx context.Context, arg UpdateProjectParams) (Project, error) {
	row := q.db.QueryRow(ctx, updateProject, arg.ID, arg.Name, arg.Description)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.OwnerID,
		&i.Name,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateSprint = `-- name: UpdateSprint :one
UPDATE sprints
SET name = $2, description = $3, start_date = $4, end_date = $5, updated_at = now()
WHERE id = $1
RETURNING id, project_id, name, description, start_date, end_date, is_completed, is_started, created_at, updated_at
`

type UpdateSprintParams struct {
	ID          uuid.UUID `json:"id"`
	Name        string    `json:"name"`
	Description *string   `json:"description"`
	StartDate   time.Time `json:"startDate"`
	EndDate     time.Time `json:"endDate"`
}

func (q *Queries) UpdateSprint(ctx context.Context, arg UpdateSprintParams) (Sprint, error) {
	row := q.db.QueryRow(ctx, updateSprint,
		arg.ID,
		arg.Name,
		arg.Description,
		arg.StartDate,
		arg.EndDate,
	)
	var i Sprint
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.Name,
		&i.Description,
		&i.StartDate,
		&i.EndDate,
		&i.IsCompleted,
		&i.IsStarted,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateSprintStatus = `-- name: UpdateSprintStatus :one
UPDATE sprints
SET is_started = $2, is_completed = $3, updated_at = now()
WHERE id = $1
RETURNING id, project_id, name, description, start_date, end_date, is_completed, is_started, created_at, updated_at
`

type UpdateSprintStatusParams struct {
	ID          uuid.UUID `json:"id"`
	IsStarted   bool      `json:"isStarted"`
	IsCompleted bool      `json:"isCompleted"`
}

func (q *Queries) UpdateSprintStatus(ctx context.Context, arg UpdateSprintStatusParams) (Sprint, error) {
	row := q.db.QueryRow(ctx, updateSprintStatus, arg.ID, arg.IsStarted, arg.IsCompleted)
	var i Sprint
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.Name,
		&i.Description,
		&i.StartDate,
		&i.EndDate,
		&i.IsCompleted,
		&i.IsStarted,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateTask = `-- name: UpdateTask :one
UPDATE tasks
SET title = $2, description = $3, assignee_id = $4, updated_at = now()
WHERE id = $1
RETURNING id, project_id, sprint_id, assignee_id, title, description, status, created_at, updated_at
`

type UpdateTaskParams struct {
	ID          uuid.UUID   `json:"id"`
	Title       string      `json:"title"`
	Description *string     `json:"description"`
	AssigneeID  pgtype.UUID `json:"assigneeId"`
}

func (q *Queries) UpdateTask(ctx context.Context, arg UpdateTaskParams) (Task, error) {
	row := q.db.QueryRow(ctx, updateTask,
		arg.ID,
		arg.Title,
		arg.Description,
		arg.AssigneeID,
	)
	var i Task
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.SprintID,
		&i.AssigneeID,
		&i.Title,
		&i.Description,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateTaskStatus = `-- name: UpdateTaskStatus :one
UPDATE tasks
SET status = $2, updated_at = now()
WHERE id = $1
RETURNING id, project_id, sprint_id, assignee_id, title, description, status, created_at, updated_at
`

type UpdateTaskStatusParams struct {
	ID     uuid.UUID `json:"id"`
	Status int32     `json:"status"`
}

func (q *Queries) UpdateTaskStatus(ctx context.Context, arg UpdateTaskStatusParams) (Task, error) {
	row := q.db.QueryRow(ctx, updateTaskStatus, arg.ID, arg.Status)
	var i Task
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.SprintID,
		&i.AssigneeID,
		&i.Title,
		&i.Description,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateUser = `-- name: UpdateUser :one
UPDATE users
SET username = $2, email = $3, first_name = $4, last_name = $5, avatar_url = $6, updated_at = now()
WHERE id = $1
RETURNING id, username, email, first_name, last_name, active, avatar_url, created_at, updated_at
`

type UpdateUserParams struct {
	ID        uuid.UUID `json:"id"`
	Username  string    `json:"username"`
	Email     string    `json:"email"`
	FirstName string    `json:"firstName"`
	LastName  string    `json:"lastName"`
	AvatarUrl *string   `json:"avatarUrl"`
}

type UpdateUserRow struct {
	ID        uuid.UUID `json:"id"`
	Username  string    `json:"username"`
	Email     string    `json:"email"`
	FirstName string    `json:"firstName"`
	LastName  string    `json:"lastName"`
	Active    bool      `json:"active"`
	AvatarUrl *string   `json:"avatarUrl"`
	CreatedAt time.Time `json:"createdAt"`
	UpdatedAt time.Time `json:"updatedAt"`
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) (UpdateUserRow, error) {
	row := q.db.QueryRow(ctx, updateUser,
		arg.ID,
		arg.Username,
		arg.Email,
		arg.FirstName,
		arg.LastName,
		arg.AvatarUrl,
	)
	var i UpdateUserRow
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.FirstName,
		&i.LastName,
		&i.Active,
		&i.AvatarUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateUserPassword = `-- name: UpdateUserPassword :exec
UPDATE users
SET password_h = $2, updated_at = now()
WHERE id = $1
`

type UpdateUserPasswordParams struct {
	ID        uuid.UUID `json:"id"`
	PasswordH string    `json:"passwordH"`
}

func (q *Queries) UpdateUserPassword(ctx context.Context, arg UpdateUserPasswordParams) error {
	_, err := q.db.Exec(ctx, updateUserPassword, arg.ID, arg.PasswordH)
	return err
}
