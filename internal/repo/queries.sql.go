// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package repo

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const addProjectMember = `-- name: AddProjectMember :exec
INSERT INTO project_members (project_id, user_id, role)
VALUES ($1, $2, $3)
ON CONFLICT (project_id, user_id) DO UPDATE SET role = EXCLUDED.role
`

type AddProjectMemberParams struct {
	ProjectID uuid.UUID `json:"projectId"`
	UserID    uuid.UUID `json:"userId"`
	Role      string    `json:"role"`
}

// Idempotent: Uses ON CONFLICT to prevent duplicates
func (q *Queries) AddProjectMember(ctx context.Context, arg AddProjectMemberParams) error {
	_, err := q.db.Exec(ctx, addProjectMember, arg.ProjectID, arg.UserID, arg.Role)
	return err
}

const checkProjectAccess = `-- name: CheckProjectAccess :one
SELECT EXISTS(
    SELECT 1 FROM project_members pm 
    WHERE pm.project_id = $1 AND pm.user_id = $2
) as has_access
`

type CheckProjectAccessParams struct {
	ProjectID uuid.UUID `json:"projectId"`
	UserID    uuid.UUID `json:"userId"`
}

// Check if user is a project member (canonical model: project_members is single source of truth, includes owner)
func (q *Queries) CheckProjectAccess(ctx context.Context, arg CheckProjectAccessParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkProjectAccess, arg.ProjectID, arg.UserID)
	var has_access bool
	err := row.Scan(&has_access)
	return has_access, err
}

const checkProjectOwner = `-- name: CheckProjectOwner :one
SELECT EXISTS(
    SELECT 1 FROM projects p
    WHERE p.id = $1 AND p.owner_id = $2
) as is_owner
`

type CheckProjectOwnerParams struct {
	ID      uuid.UUID `json:"id"`
	OwnerID uuid.UUID `json:"ownerId"`
}

func (q *Queries) CheckProjectOwner(ctx context.Context, arg CheckProjectOwnerParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkProjectOwner, arg.ID, arg.OwnerID)
	var is_owner bool
	err := row.Scan(&is_owner)
	return is_owner, err
}

const checkProjectOwnerOrAdmin = `-- name: CheckProjectOwnerOrAdmin :one
SELECT (
    EXISTS(SELECT 1 FROM projects p WHERE p.id = $1 AND p.owner_id = $2) OR
    EXISTS(SELECT 1 FROM project_members pm WHERE pm.project_id = $1 AND pm.user_id = $2 AND pm.role = 'admin')
)::boolean as is_owner_or_admin
`

type CheckProjectOwnerOrAdminParams struct {
	ID      uuid.UUID `json:"id"`
	OwnerID uuid.UUID `json:"ownerId"`
}

// Check if user is project owner OR has admin role in project_members
func (q *Queries) CheckProjectOwnerOrAdmin(ctx context.Context, arg CheckProjectOwnerOrAdminParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkProjectOwnerOrAdmin, arg.ID, arg.OwnerID)
	var is_owner_or_admin bool
	err := row.Scan(&is_owner_or_admin)
	return is_owner_or_admin, err
}

const createMessage = `-- name: CreateMessage :one
INSERT INTO messages (project_id, sender_id, content, message_type, parent_message_id)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, project_id, sender_id, content, message_type, parent_message_id, created_at, updated_at
`

type CreateMessageParams struct {
	ProjectID       uuid.UUID   `json:"projectId"`
	SenderID        uuid.UUID   `json:"senderId"`
	Content         string      `json:"content"`
	MessageType     string      `json:"messageType"`
	ParentMessageID pgtype.UUID `json:"parentMessageId"`
}

func (q *Queries) CreateMessage(ctx context.Context, arg CreateMessageParams) (Message, error) {
	row := q.db.QueryRow(ctx, createMessage,
		arg.ProjectID,
		arg.SenderID,
		arg.Content,
		arg.MessageType,
		arg.ParentMessageID,
	)
	var i Message
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.SenderID,
		&i.Content,
		&i.MessageType,
		&i.ParentMessageID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createOAuthState = `-- name: CreateOAuthState :one
INSERT INTO oauth_state (state_token, remember_me, redirect_url, expires_at)
VALUES ($1, $2, $3, $4)
RETURNING id, state_token, remember_me, redirect_url, created_at, expires_at
`

type CreateOAuthStateParams struct {
	StateToken  string    `json:"stateToken"`
	RememberMe  bool      `json:"rememberMe"`
	RedirectUrl *string   `json:"redirectUrl"`
	ExpiresAt   time.Time `json:"expiresAt"`
}

// OAuth State Queries
func (q *Queries) CreateOAuthState(ctx context.Context, arg CreateOAuthStateParams) (OauthState, error) {
	row := q.db.QueryRow(ctx, createOAuthState,
		arg.StateToken,
		arg.RememberMe,
		arg.RedirectUrl,
		arg.ExpiresAt,
	)
	var i OauthState
	err := row.Scan(
		&i.ID,
		&i.StateToken,
		&i.RememberMe,
		&i.RedirectUrl,
		&i.CreatedAt,
		&i.ExpiresAt,
	)
	return i, err
}

const createOAuthUser = `-- name: CreateOAuthUser :one
INSERT INTO users (username, email, first_name, last_name, auth_provider, google_id, profile_picture_url)
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id, username, email, first_name, last_name, auth_provider, google_id, profile_picture_url, active, avatar_url, created_at, updated_at
`

type CreateOAuthUserParams struct {
	Username          string  `json:"username"`
	Email             string  `json:"email"`
	FirstName         string  `json:"firstName"`
	LastName          string  `json:"lastName"`
	AuthProvider      *string `json:"authProvider"`
	GoogleID          *string `json:"googleId"`
	ProfilePictureUrl *string `json:"profilePictureUrl"`
}

type CreateOAuthUserRow struct {
	ID                uuid.UUID `json:"id"`
	Username          string    `json:"username"`
	Email             string    `json:"email"`
	FirstName         string    `json:"firstName"`
	LastName          string    `json:"lastName"`
	AuthProvider      *string   `json:"authProvider"`
	GoogleID          *string   `json:"googleId"`
	ProfilePictureUrl *string   `json:"profilePictureUrl"`
	Active            bool      `json:"active"`
	AvatarUrl         *string   `json:"avatarUrl"`
	CreatedAt         time.Time `json:"createdAt"`
	UpdatedAt         time.Time `json:"updatedAt"`
}

func (q *Queries) CreateOAuthUser(ctx context.Context, arg CreateOAuthUserParams) (CreateOAuthUserRow, error) {
	row := q.db.QueryRow(ctx, createOAuthUser,
		arg.Username,
		arg.Email,
		arg.FirstName,
		arg.LastName,
		arg.AuthProvider,
		arg.GoogleID,
		arg.ProfilePictureUrl,
	)
	var i CreateOAuthUserRow
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.FirstName,
		&i.LastName,
		&i.AuthProvider,
		&i.GoogleID,
		&i.ProfilePictureUrl,
		&i.Active,
		&i.AvatarUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createPasswordReset = `-- name: CreatePasswordReset :one
INSERT INTO password_resets (user_id, reset_token, expires_at)
VALUES ($1, $2, $3)
RETURNING id, user_id, reset_token, expires_at, created_at
`

type CreatePasswordResetParams struct {
	UserID     uuid.UUID `json:"userId"`
	ResetToken string    `json:"resetToken"`
	ExpiresAt  time.Time `json:"expiresAt"`
}

func (q *Queries) CreatePasswordReset(ctx context.Context, arg CreatePasswordResetParams) (PasswordReset, error) {
	row := q.db.QueryRow(ctx, createPasswordReset, arg.UserID, arg.ResetToken, arg.ExpiresAt)
	var i PasswordReset
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ResetToken,
		&i.ExpiresAt,
		&i.CreatedAt,
	)
	return i, err
}

const createProject = `-- name: CreateProject :one
INSERT INTO projects (owner_id, name, description)
VALUES ($1, $2, $3)
RETURNING id, owner_id, name, description, created_at, updated_at
`

type CreateProjectParams struct {
	OwnerID     uuid.UUID `json:"ownerId"`
	Name        string    `json:"name"`
	Description *string   `json:"description"`
}

func (q *Queries) CreateProject(ctx context.Context, arg CreateProjectParams) (Project, error) {
	row := q.db.QueryRow(ctx, createProject, arg.OwnerID, arg.Name, arg.Description)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.OwnerID,
		&i.Name,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createProjectInvite = `-- name: CreateProjectInvite :one
INSERT INTO project_invites (project_id, created_by, invite_token, expires_at, max_uses)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, project_id, created_by, invite_token, expires_at, max_uses, used_count, is_active, created_at, updated_at
`

type CreateProjectInviteParams struct {
	ProjectID   uuid.UUID `json:"projectId"`
	CreatedBy   uuid.UUID `json:"createdBy"`
	InviteToken string    `json:"inviteToken"`
	ExpiresAt   time.Time `json:"expiresAt"`
	MaxUses     *int32    `json:"maxUses"`
}

func (q *Queries) CreateProjectInvite(ctx context.Context, arg CreateProjectInviteParams) (ProjectInvite, error) {
	row := q.db.QueryRow(ctx, createProjectInvite,
		arg.ProjectID,
		arg.CreatedBy,
		arg.InviteToken,
		arg.ExpiresAt,
		arg.MaxUses,
	)
	var i ProjectInvite
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.CreatedBy,
		&i.InviteToken,
		&i.ExpiresAt,
		&i.MaxUses,
		&i.UsedCount,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createRefreshToken = `-- name: CreateRefreshToken :one
INSERT INTO refresh_tokens (user_id, token, expires_at, is_persistent)
VALUES ($1, $2, $3, $4)
RETURNING id, user_id, token, expires_at, is_persistent, created_at
`

type CreateRefreshTokenParams struct {
	UserID       uuid.UUID `json:"userId"`
	Token        string    `json:"token"`
	ExpiresAt    time.Time `json:"expiresAt"`
	IsPersistent bool      `json:"isPersistent"`
}

type CreateRefreshTokenRow struct {
	ID           uuid.UUID `json:"id"`
	UserID       uuid.UUID `json:"userId"`
	Token        string    `json:"token"`
	ExpiresAt    time.Time `json:"expiresAt"`
	IsPersistent bool      `json:"isPersistent"`
	CreatedAt    time.Time `json:"createdAt"`
}

// Refresh Token Queries
func (q *Queries) CreateRefreshToken(ctx context.Context, arg CreateRefreshTokenParams) (CreateRefreshTokenRow, error) {
	row := q.db.QueryRow(ctx, createRefreshToken,
		arg.UserID,
		arg.Token,
		arg.ExpiresAt,
		arg.IsPersistent,
	)
	var i CreateRefreshTokenRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Token,
		&i.ExpiresAt,
		&i.IsPersistent,
		&i.CreatedAt,
	)
	return i, err
}

const createRefreshTokenWithGoogle = `-- name: CreateRefreshTokenWithGoogle :one
INSERT INTO refresh_tokens (user_id, token, expires_at, is_persistent, google_refresh_token, google_access_token, google_token_expiry)
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id, user_id, token, expires_at, is_persistent, google_refresh_token, google_access_token, google_token_expiry, created_at
`

type CreateRefreshTokenWithGoogleParams struct {
	UserID             uuid.UUID          `json:"userId"`
	Token              string             `json:"token"`
	ExpiresAt          time.Time          `json:"expiresAt"`
	IsPersistent       bool               `json:"isPersistent"`
	GoogleRefreshToken *string            `json:"googleRefreshToken"`
	GoogleAccessToken  *string            `json:"googleAccessToken"`
	GoogleTokenExpiry  pgtype.Timestamptz `json:"googleTokenExpiry"`
}

type CreateRefreshTokenWithGoogleRow struct {
	ID                 uuid.UUID          `json:"id"`
	UserID             uuid.UUID          `json:"userId"`
	Token              string             `json:"token"`
	ExpiresAt          time.Time          `json:"expiresAt"`
	IsPersistent       bool               `json:"isPersistent"`
	GoogleRefreshToken *string            `json:"googleRefreshToken"`
	GoogleAccessToken  *string            `json:"googleAccessToken"`
	GoogleTokenExpiry  pgtype.Timestamptz `json:"googleTokenExpiry"`
	CreatedAt          time.Time          `json:"createdAt"`
}

// OAuth Refresh Token Queries
func (q *Queries) CreateRefreshTokenWithGoogle(ctx context.Context, arg CreateRefreshTokenWithGoogleParams) (CreateRefreshTokenWithGoogleRow, error) {
	row := q.db.QueryRow(ctx, createRefreshTokenWithGoogle,
		arg.UserID,
		arg.Token,
		arg.ExpiresAt,
		arg.IsPersistent,
		arg.GoogleRefreshToken,
		arg.GoogleAccessToken,
		arg.GoogleTokenExpiry,
	)
	var i CreateRefreshTokenWithGoogleRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Token,
		&i.ExpiresAt,
		&i.IsPersistent,
		&i.GoogleRefreshToken,
		&i.GoogleAccessToken,
		&i.GoogleTokenExpiry,
		&i.CreatedAt,
	)
	return i, err
}

const createSprint = `-- name: CreateSprint :one
INSERT INTO sprints (project_id, name, description, start_date, end_date)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, project_id, name, description, start_date, end_date, is_completed, is_started, created_at, updated_at
`

type CreateSprintParams struct {
	ProjectID   uuid.UUID `json:"projectId"`
	Name        string    `json:"name"`
	Description *string   `json:"description"`
	StartDate   time.Time `json:"startDate"`
	EndDate     time.Time `json:"endDate"`
}

func (q *Queries) CreateSprint(ctx context.Context, arg CreateSprintParams) (Sprint, error) {
	row := q.db.QueryRow(ctx, createSprint,
		arg.ProjectID,
		arg.Name,
		arg.Description,
		arg.StartDate,
		arg.EndDate,
	)
	var i Sprint
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.Name,
		&i.Description,
		&i.StartDate,
		&i.EndDate,
		&i.IsCompleted,
		&i.IsStarted,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createTask = `-- name: CreateTask :one
INSERT INTO tasks (project_id, sprint_id, assignee_id, description, status)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, project_id, sprint_id, assignee_id, description, status, created_at, updated_at
`

type CreateTaskParams struct {
	ProjectID   uuid.UUID   `json:"projectId"`
	SprintID    pgtype.UUID `json:"sprintId"`
	AssigneeID  pgtype.UUID `json:"assigneeId"`
	Description *string     `json:"description"`
	Status      int32       `json:"status"`
}

type CreateTaskRow struct {
	ID          uuid.UUID   `json:"id"`
	ProjectID   uuid.UUID   `json:"projectId"`
	SprintID    pgtype.UUID `json:"sprintId"`
	AssigneeID  pgtype.UUID `json:"assigneeId"`
	Description *string     `json:"description"`
	Status      int32       `json:"status"`
	CreatedAt   time.Time   `json:"createdAt"`
	UpdatedAt   time.Time   `json:"updatedAt"`
}

func (q *Queries) CreateTask(ctx context.Context, arg CreateTaskParams) (CreateTaskRow, error) {
	row := q.db.QueryRow(ctx, createTask,
		arg.ProjectID,
		arg.SprintID,
		arg.AssigneeID,
		arg.Description,
		arg.Status,
	)
	var i CreateTaskRow
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.SprintID,
		&i.AssigneeID,
		&i.Description,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (username, email, password_h, first_name, last_name)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, username, email, first_name, last_name, active, avatar_url, created_at, updated_at
`

type CreateUserParams struct {
	Username  string  `json:"username"`
	Email     string  `json:"email"`
	PasswordH *string `json:"passwordH"`
	FirstName string  `json:"firstName"`
	LastName  string  `json:"lastName"`
}

type CreateUserRow struct {
	ID        uuid.UUID `json:"id"`
	Username  string    `json:"username"`
	Email     string    `json:"email"`
	FirstName string    `json:"firstName"`
	LastName  string    `json:"lastName"`
	Active    bool      `json:"active"`
	AvatarUrl *string   `json:"avatarUrl"`
	CreatedAt time.Time `json:"createdAt"`
	UpdatedAt time.Time `json:"updatedAt"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (CreateUserRow, error) {
	row := q.db.QueryRow(ctx, createUser,
		arg.Username,
		arg.Email,
		arg.PasswordH,
		arg.FirstName,
		arg.LastName,
	)
	var i CreateUserRow
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.FirstName,
		&i.LastName,
		&i.Active,
		&i.AvatarUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deactivateInvite = `-- name: DeactivateInvite :exec
UPDATE project_invites
SET is_active = false, updated_at = now()
WHERE id = $1
`

func (q *Queries) DeactivateInvite(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deactivateInvite, id)
	return err
}

const deactivateUser = `-- name: DeactivateUser :exec
UPDATE users
SET active = false, updated_at = now()
WHERE id = $1
`

func (q *Queries) DeactivateUser(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deactivateUser, id)
	return err
}

const deleteExpiredOAuthStates = `-- name: DeleteExpiredOAuthStates :exec
DELETE FROM oauth_state WHERE expires_at < now()
`

func (q *Queries) DeleteExpiredOAuthStates(ctx context.Context) error {
	_, err := q.db.Exec(ctx, deleteExpiredOAuthStates)
	return err
}

const deleteExpiredPasswordResets = `-- name: DeleteExpiredPasswordResets :exec
DELETE FROM password_resets WHERE expires_at < now()
`

func (q *Queries) DeleteExpiredPasswordResets(ctx context.Context) error {
	_, err := q.db.Exec(ctx, deleteExpiredPasswordResets)
	return err
}

const deleteExpiredRefreshTokens = `-- name: DeleteExpiredRefreshTokens :exec
DELETE FROM refresh_tokens WHERE expires_at < now()
`

func (q *Queries) DeleteExpiredRefreshTokens(ctx context.Context) error {
	_, err := q.db.Exec(ctx, deleteExpiredRefreshTokens)
	return err
}

const deleteMessage = `-- name: DeleteMessage :exec
DELETE FROM messages WHERE id = $1
`

func (q *Queries) DeleteMessage(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteMessage, id)
	return err
}

const deleteOAuthState = `-- name: DeleteOAuthState :exec
DELETE FROM oauth_state WHERE state_token = $1
`

func (q *Queries) DeleteOAuthState(ctx context.Context, stateToken string) error {
	_, err := q.db.Exec(ctx, deleteOAuthState, stateToken)
	return err
}

const deletePasswordReset = `-- name: DeletePasswordReset :exec
DELETE FROM password_resets WHERE reset_token = $1
`

func (q *Queries) DeletePasswordReset(ctx context.Context, resetToken string) error {
	_, err := q.db.Exec(ctx, deletePasswordReset, resetToken)
	return err
}

const deleteProject = `-- name: DeleteProject :exec
DELETE FROM projects WHERE id = $1
`

func (q *Queries) DeleteProject(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteProject, id)
	return err
}

const deleteRefreshToken = `-- name: DeleteRefreshToken :exec
DELETE FROM refresh_tokens WHERE token = $1
`

func (q *Queries) DeleteRefreshToken(ctx context.Context, token string) error {
	_, err := q.db.Exec(ctx, deleteRefreshToken, token)
	return err
}

const deleteSprint = `-- name: DeleteSprint :exec
DELETE FROM sprints WHERE id = $1
`

func (q *Queries) DeleteSprint(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteSprint, id)
	return err
}

const deleteTask = `-- name: DeleteTask :exec
DELETE FROM tasks WHERE id = $1
`

func (q *Queries) DeleteTask(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteTask, id)
	return err
}

const deleteUserRefreshTokens = `-- name: DeleteUserRefreshTokens :exec
DELETE FROM refresh_tokens WHERE user_id = $1
`

func (q *Queries) DeleteUserRefreshTokens(ctx context.Context, userID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteUserRefreshTokens, userID)
	return err
}

const getMessageByID = `-- name: GetMessageByID :one
SELECT m.id, m.project_id, m.sender_id, m.content, m.message_type, m.parent_message_id, m.created_at, m.updated_at,
       u.username as sender_username, u.first_name as sender_first_name, u.last_name as sender_last_name, u.avatar_url as sender_avatar_url
FROM messages m
JOIN users u ON m.sender_id = u.id
WHERE m.id = $1
`

type GetMessageByIDRow struct {
	ID              uuid.UUID   `json:"id"`
	ProjectID       uuid.UUID   `json:"projectId"`
	SenderID        uuid.UUID   `json:"senderId"`
	Content         string      `json:"content"`
	MessageType     string      `json:"messageType"`
	ParentMessageID pgtype.UUID `json:"parentMessageId"`
	CreatedAt       time.Time   `json:"createdAt"`
	UpdatedAt       time.Time   `json:"updatedAt"`
	SenderUsername  string      `json:"senderUsername"`
	SenderFirstName string      `json:"senderFirstName"`
	SenderLastName  string      `json:"senderLastName"`
	SenderAvatarUrl *string     `json:"senderAvatarUrl"`
}

func (q *Queries) GetMessageByID(ctx context.Context, id uuid.UUID) (GetMessageByIDRow, error) {
	row := q.db.QueryRow(ctx, getMessageByID, id)
	var i GetMessageByIDRow
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.SenderID,
		&i.Content,
		&i.MessageType,
		&i.ParentMessageID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.SenderUsername,
		&i.SenderFirstName,
		&i.SenderLastName,
		&i.SenderAvatarUrl,
	)
	return i, err
}

const getOAuthState = `-- name: GetOAuthState :one
SELECT id, state_token, remember_me, redirect_url, created_at, expires_at
FROM oauth_state
WHERE state_token = $1 AND expires_at > now()
`

func (q *Queries) GetOAuthState(ctx context.Context, stateToken string) (OauthState, error) {
	row := q.db.QueryRow(ctx, getOAuthState, stateToken)
	var i OauthState
	err := row.Scan(
		&i.ID,
		&i.StateToken,
		&i.RememberMe,
		&i.RedirectUrl,
		&i.CreatedAt,
		&i.ExpiresAt,
	)
	return i, err
}

const getPasswordResetByToken = `-- name: GetPasswordResetByToken :one
SELECT pr.id, pr.user_id, pr.reset_token, pr.expires_at, pr.created_at,
       u.username, u.email, u.first_name, u.last_name
FROM password_resets pr
JOIN users u ON pr.user_id = u.id
WHERE pr.reset_token = $1
`

type GetPasswordResetByTokenRow struct {
	ID         int32     `json:"id"`
	UserID     uuid.UUID `json:"userId"`
	ResetToken string    `json:"resetToken"`
	ExpiresAt  time.Time `json:"expiresAt"`
	CreatedAt  time.Time `json:"createdAt"`
	Username   string    `json:"username"`
	Email      string    `json:"email"`
	FirstName  string    `json:"firstName"`
	LastName   string    `json:"lastName"`
}

func (q *Queries) GetPasswordResetByToken(ctx context.Context, resetToken string) (GetPasswordResetByTokenRow, error) {
	row := q.db.QueryRow(ctx, getPasswordResetByToken, resetToken)
	var i GetPasswordResetByTokenRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ResetToken,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.Username,
		&i.Email,
		&i.FirstName,
		&i.LastName,
	)
	return i, err
}

const getProjectByID = `-- name: GetProjectByID :one
SELECT p.id, p.owner_id, p.name, p.description, p.created_at, p.updated_at,
       u.id as owner_id, u.username as owner_username, u.email as owner_email,
       u.first_name as owner_first_name, u.last_name as owner_last_name
FROM projects p
JOIN users u ON p.owner_id = u.id
WHERE p.id = $1
`

type GetProjectByIDRow struct {
	ID             uuid.UUID `json:"id"`
	OwnerID        uuid.UUID `json:"ownerId"`
	Name           string    `json:"name"`
	Description    *string   `json:"description"`
	CreatedAt      time.Time `json:"createdAt"`
	UpdatedAt      time.Time `json:"updatedAt"`
	OwnerID_2      uuid.UUID `json:"ownerId2"`
	OwnerUsername  string    `json:"ownerUsername"`
	OwnerEmail     string    `json:"ownerEmail"`
	OwnerFirstName string    `json:"ownerFirstName"`
	OwnerLastName  string    `json:"ownerLastName"`
}

func (q *Queries) GetProjectByID(ctx context.Context, id uuid.UUID) (GetProjectByIDRow, error) {
	row := q.db.QueryRow(ctx, getProjectByID, id)
	var i GetProjectByIDRow
	err := row.Scan(
		&i.ID,
		&i.OwnerID,
		&i.Name,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.OwnerID_2,
		&i.OwnerUsername,
		&i.OwnerEmail,
		&i.OwnerFirstName,
		&i.OwnerLastName,
	)
	return i, err
}

const getProjectInviteByID = `-- name: GetProjectInviteByID :one
SELECT id, project_id, created_by, invite_token, expires_at, max_uses, used_count, is_active, created_at, updated_at
FROM project_invites
WHERE id = $1
`

func (q *Queries) GetProjectInviteByID(ctx context.Context, id uuid.UUID) (ProjectInvite, error) {
	row := q.db.QueryRow(ctx, getProjectInviteByID, id)
	var i ProjectInvite
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.CreatedBy,
		&i.InviteToken,
		&i.ExpiresAt,
		&i.MaxUses,
		&i.UsedCount,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getProjectInviteByToken = `-- name: GetProjectInviteByToken :one
SELECT id, project_id, created_by, invite_token, expires_at, max_uses, used_count, is_active, created_at, updated_at
FROM project_invites
WHERE invite_token = $1 AND is_active = true
`

func (q *Queries) GetProjectInviteByToken(ctx context.Context, inviteToken string) (ProjectInvite, error) {
	row := q.db.QueryRow(ctx, getProjectInviteByToken, inviteToken)
	var i ProjectInvite
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.CreatedBy,
		&i.InviteToken,
		&i.ExpiresAt,
		&i.MaxUses,
		&i.UsedCount,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getProjectMembers = `-- name: GetProjectMembers :many
SELECT pm.project_id, pm.user_id, pm.role, pm.joined_at,
       u.username, u.email, u.first_name, u.last_name, u.avatar_url
FROM project_members pm
JOIN users u ON pm.user_id = u.id
WHERE pm.project_id = $1
ORDER BY pm.joined_at
`

type GetProjectMembersRow struct {
	ProjectID uuid.UUID `json:"projectId"`
	UserID    uuid.UUID `json:"userId"`
	Role      string    `json:"role"`
	JoinedAt  time.Time `json:"joinedAt"`
	Username  string    `json:"username"`
	Email     string    `json:"email"`
	FirstName string    `json:"firstName"`
	LastName  string    `json:"lastName"`
	AvatarUrl *string   `json:"avatarUrl"`
}

// Canonical model: project_members is single source of truth (includes owner)
func (q *Queries) GetProjectMembers(ctx context.Context, projectID uuid.UUID) ([]GetProjectMembersRow, error) {
	rows, err := q.db.Query(ctx, getProjectMembers, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProjectMembersRow
	for rows.Next() {
		var i GetProjectMembersRow
		if err := rows.Scan(
			&i.ProjectID,
			&i.UserID,
			&i.Role,
			&i.JoinedAt,
			&i.Username,
			&i.Email,
			&i.FirstName,
			&i.LastName,
			&i.AvatarUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRefreshToken = `-- name: GetRefreshToken :one
SELECT id, user_id, token, expires_at, is_persistent, created_at
FROM refresh_tokens
WHERE token = $1
`

type GetRefreshTokenRow struct {
	ID           uuid.UUID `json:"id"`
	UserID       uuid.UUID `json:"userId"`
	Token        string    `json:"token"`
	ExpiresAt    time.Time `json:"expiresAt"`
	IsPersistent bool      `json:"isPersistent"`
	CreatedAt    time.Time `json:"createdAt"`
}

func (q *Queries) GetRefreshToken(ctx context.Context, token string) (GetRefreshTokenRow, error) {
	row := q.db.QueryRow(ctx, getRefreshToken, token)
	var i GetRefreshTokenRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Token,
		&i.ExpiresAt,
		&i.IsPersistent,
		&i.CreatedAt,
	)
	return i, err
}

const getSprintByID = `-- name: GetSprintByID :one
SELECT s.id, s.project_id, s.name, s.description, s.start_date, s.end_date, s.is_completed, s.is_started, s.created_at, s.updated_at,
       p.owner_id, u.username as owner_username, u.email as owner_email, u.first_name as owner_first_name, u.last_name as owner_last_name
FROM sprints s
JOIN projects p ON s.project_id = p.id
JOIN users u ON p.owner_id = u.id
WHERE s.id = $1
`

type GetSprintByIDRow struct {
	ID             uuid.UUID `json:"id"`
	ProjectID      uuid.UUID `json:"projectId"`
	Name           string    `json:"name"`
	Description    *string   `json:"description"`
	StartDate      time.Time `json:"startDate"`
	EndDate        time.Time `json:"endDate"`
	IsCompleted    bool      `json:"isCompleted"`
	IsStarted      bool      `json:"isStarted"`
	CreatedAt      time.Time `json:"createdAt"`
	UpdatedAt      time.Time `json:"updatedAt"`
	OwnerID        uuid.UUID `json:"ownerId"`
	OwnerUsername  string    `json:"ownerUsername"`
	OwnerEmail     string    `json:"ownerEmail"`
	OwnerFirstName string    `json:"ownerFirstName"`
	OwnerLastName  string    `json:"ownerLastName"`
}

func (q *Queries) GetSprintByID(ctx context.Context, id uuid.UUID) (GetSprintByIDRow, error) {
	row := q.db.QueryRow(ctx, getSprintByID, id)
	var i GetSprintByIDRow
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.Name,
		&i.Description,
		&i.StartDate,
		&i.EndDate,
		&i.IsCompleted,
		&i.IsStarted,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.OwnerID,
		&i.OwnerUsername,
		&i.OwnerEmail,
		&i.OwnerFirstName,
		&i.OwnerLastName,
	)
	return i, err
}

const getTaskByID = `-- name: GetTaskByID :one
SELECT t.id, t.project_id, t.sprint_id, t.assignee_id, t.description, t.status, t.created_at, t.updated_at,
       u.username as assignee_username, u.first_name as assignee_first_name, u.last_name as assignee_last_name,
       p.owner_id, owner.username as owner_username, owner.email as owner_email, owner.first_name as owner_first_name, owner.last_name as owner_last_name
FROM tasks t
LEFT JOIN users u ON t.assignee_id = u.id
JOIN projects p ON t.project_id = p.id
JOIN users owner ON p.owner_id = owner.id
WHERE t.id = $1
`

type GetTaskByIDRow struct {
	ID                uuid.UUID   `json:"id"`
	ProjectID         uuid.UUID   `json:"projectId"`
	SprintID          pgtype.UUID `json:"sprintId"`
	AssigneeID        pgtype.UUID `json:"assigneeId"`
	Description       *string     `json:"description"`
	Status            int32       `json:"status"`
	CreatedAt         time.Time   `json:"createdAt"`
	UpdatedAt         time.Time   `json:"updatedAt"`
	AssigneeUsername  *string     `json:"assigneeUsername"`
	AssigneeFirstName *string     `json:"assigneeFirstName"`
	AssigneeLastName  *string     `json:"assigneeLastName"`
	OwnerID           uuid.UUID   `json:"ownerId"`
	OwnerUsername     string      `json:"ownerUsername"`
	OwnerEmail        string      `json:"ownerEmail"`
	OwnerFirstName    string      `json:"ownerFirstName"`
	OwnerLastName     string      `json:"ownerLastName"`
}

func (q *Queries) GetTaskByID(ctx context.Context, id uuid.UUID) (GetTaskByIDRow, error) {
	row := q.db.QueryRow(ctx, getTaskByID, id)
	var i GetTaskByIDRow
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.SprintID,
		&i.AssigneeID,
		&i.Description,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.AssigneeUsername,
		&i.AssigneeFirstName,
		&i.AssigneeLastName,
		&i.OwnerID,
		&i.OwnerUsername,
		&i.OwnerEmail,
		&i.OwnerFirstName,
		&i.OwnerLastName,
	)
	return i, err
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, username, email, password_h, first_name, last_name, active, avatar_url, created_at, updated_at
FROM users
WHERE lower(email) = lower($1)
`

type GetUserByEmailRow struct {
	ID        uuid.UUID `json:"id"`
	Username  string    `json:"username"`
	Email     string    `json:"email"`
	PasswordH *string   `json:"passwordH"`
	FirstName string    `json:"firstName"`
	LastName  string    `json:"lastName"`
	Active    bool      `json:"active"`
	AvatarUrl *string   `json:"avatarUrl"`
	CreatedAt time.Time `json:"createdAt"`
	UpdatedAt time.Time `json:"updatedAt"`
}

func (q *Queries) GetUserByEmail(ctx context.Context, lower string) (GetUserByEmailRow, error) {
	row := q.db.QueryRow(ctx, getUserByEmail, lower)
	var i GetUserByEmailRow
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.PasswordH,
		&i.FirstName,
		&i.LastName,
		&i.Active,
		&i.AvatarUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserByGoogleID = `-- name: GetUserByGoogleID :one
SELECT id, username, email, first_name, last_name, auth_provider, google_id, profile_picture_url, active, avatar_url, created_at, updated_at
FROM users
WHERE google_id = $1
`

type GetUserByGoogleIDRow struct {
	ID                uuid.UUID `json:"id"`
	Username          string    `json:"username"`
	Email             string    `json:"email"`
	FirstName         string    `json:"firstName"`
	LastName          string    `json:"lastName"`
	AuthProvider      *string   `json:"authProvider"`
	GoogleID          *string   `json:"googleId"`
	ProfilePictureUrl *string   `json:"profilePictureUrl"`
	Active            bool      `json:"active"`
	AvatarUrl         *string   `json:"avatarUrl"`
	CreatedAt         time.Time `json:"createdAt"`
	UpdatedAt         time.Time `json:"updatedAt"`
}

// OAuth User Queries
func (q *Queries) GetUserByGoogleID(ctx context.Context, googleID *string) (GetUserByGoogleIDRow, error) {
	row := q.db.QueryRow(ctx, getUserByGoogleID, googleID)
	var i GetUserByGoogleIDRow
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.FirstName,
		&i.LastName,
		&i.AuthProvider,
		&i.GoogleID,
		&i.ProfilePictureUrl,
		&i.Active,
		&i.AvatarUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT id, username, email, first_name, last_name, active, avatar_url, created_at, updated_at
FROM users
WHERE id = $1
`

type GetUserByIDRow struct {
	ID        uuid.UUID `json:"id"`
	Username  string    `json:"username"`
	Email     string    `json:"email"`
	FirstName string    `json:"firstName"`
	LastName  string    `json:"lastName"`
	Active    bool      `json:"active"`
	AvatarUrl *string   `json:"avatarUrl"`
	CreatedAt time.Time `json:"createdAt"`
	UpdatedAt time.Time `json:"updatedAt"`
}

func (q *Queries) GetUserByID(ctx context.Context, id uuid.UUID) (GetUserByIDRow, error) {
	row := q.db.QueryRow(ctx, getUserByID, id)
	var i GetUserByIDRow
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.FirstName,
		&i.LastName,
		&i.Active,
		&i.AvatarUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserByIDWithPassword = `-- name: GetUserByIDWithPassword :one
SELECT id, username, email, password_h, first_name, last_name, active, avatar_url, created_at, updated_at
FROM users
WHERE id = $1
`

type GetUserByIDWithPasswordRow struct {
	ID        uuid.UUID `json:"id"`
	Username  string    `json:"username"`
	Email     string    `json:"email"`
	PasswordH *string   `json:"passwordH"`
	FirstName string    `json:"firstName"`
	LastName  string    `json:"lastName"`
	Active    bool      `json:"active"`
	AvatarUrl *string   `json:"avatarUrl"`
	CreatedAt time.Time `json:"createdAt"`
	UpdatedAt time.Time `json:"updatedAt"`
}

func (q *Queries) GetUserByIDWithPassword(ctx context.Context, id uuid.UUID) (GetUserByIDWithPasswordRow, error) {
	row := q.db.QueryRow(ctx, getUserByIDWithPassword, id)
	var i GetUserByIDWithPasswordRow
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.PasswordH,
		&i.FirstName,
		&i.LastName,
		&i.Active,
		&i.AvatarUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserByUsername = `-- name: GetUserByUsername :one
SELECT id, username, email, password_h, first_name, last_name, active, avatar_url, created_at, updated_at
FROM users
WHERE lower(username) = lower($1)
`

type GetUserByUsernameRow struct {
	ID        uuid.UUID `json:"id"`
	Username  string    `json:"username"`
	Email     string    `json:"email"`
	PasswordH *string   `json:"passwordH"`
	FirstName string    `json:"firstName"`
	LastName  string    `json:"lastName"`
	Active    bool      `json:"active"`
	AvatarUrl *string   `json:"avatarUrl"`
	CreatedAt time.Time `json:"createdAt"`
	UpdatedAt time.Time `json:"updatedAt"`
}

func (q *Queries) GetUserByUsername(ctx context.Context, lower string) (GetUserByUsernameRow, error) {
	row := q.db.QueryRow(ctx, getUserByUsername, lower)
	var i GetUserByUsernameRow
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.PasswordH,
		&i.FirstName,
		&i.LastName,
		&i.Active,
		&i.AvatarUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserProjectRole = `-- name: GetUserProjectRole :one
SELECT 
    CASE 
        WHEN p.owner_id = $2 THEN 'owner'
        ELSE COALESCE(pm.role, NULL)
    END as role
FROM projects p
LEFT JOIN project_members pm ON p.id = pm.project_id AND pm.user_id = $2
WHERE p.id = $1
`

type GetUserProjectRoleParams struct {
	ID      uuid.UUID `json:"id"`
	OwnerID uuid.UUID `json:"ownerId"`
}

// Get the user's role in a project (returns 'owner', 'admin', 'member', 'viewer', or NULL if not a member)
func (q *Queries) GetUserProjectRole(ctx context.Context, arg GetUserProjectRoleParams) (interface{}, error) {
	row := q.db.QueryRow(ctx, getUserProjectRole, arg.ID, arg.OwnerID)
	var role interface{}
	err := row.Scan(&role)
	return role, err
}

const incrementInviteUseCount = `-- name: IncrementInviteUseCount :exec
UPDATE project_invites
SET used_count = used_count + 1, updated_at = now()
WHERE id = $1
`

func (q *Queries) IncrementInviteUseCount(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, incrementInviteUseCount, id)
	return err
}

const listMessagesByProject = `-- name: ListMessagesByProject :many
SELECT m.id, m.project_id, m.sender_id, m.content, m.message_type, m.parent_message_id, m.created_at, m.updated_at,
       u.username as sender_username, u.first_name as sender_first_name, u.last_name as sender_last_name, u.avatar_url as sender_avatar_url
FROM messages m
JOIN users u ON m.sender_id = u.id
WHERE m.project_id = $1
ORDER BY m.created_at DESC
LIMIT $2 OFFSET $3
`

type ListMessagesByProjectParams struct {
	ProjectID uuid.UUID `json:"projectId"`
	Limit     int32     `json:"limit"`
	Offset    int32     `json:"offset"`
}

type ListMessagesByProjectRow struct {
	ID              uuid.UUID   `json:"id"`
	ProjectID       uuid.UUID   `json:"projectId"`
	SenderID        uuid.UUID   `json:"senderId"`
	Content         string      `json:"content"`
	MessageType     string      `json:"messageType"`
	ParentMessageID pgtype.UUID `json:"parentMessageId"`
	CreatedAt       time.Time   `json:"createdAt"`
	UpdatedAt       time.Time   `json:"updatedAt"`
	SenderUsername  string      `json:"senderUsername"`
	SenderFirstName string      `json:"senderFirstName"`
	SenderLastName  string      `json:"senderLastName"`
	SenderAvatarUrl *string     `json:"senderAvatarUrl"`
}

func (q *Queries) ListMessagesByProject(ctx context.Context, arg ListMessagesByProjectParams) ([]ListMessagesByProjectRow, error) {
	rows, err := q.db.Query(ctx, listMessagesByProject, arg.ProjectID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListMessagesByProjectRow
	for rows.Next() {
		var i ListMessagesByProjectRow
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.SenderID,
			&i.Content,
			&i.MessageType,
			&i.ParentMessageID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SenderUsername,
			&i.SenderFirstName,
			&i.SenderLastName,
			&i.SenderAvatarUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMessagesByProjectAfter = `-- name: ListMessagesByProjectAfter :many
SELECT m.id, m.project_id, m.sender_id, m.content, m.message_type, m.parent_message_id, m.created_at, m.updated_at,
       u.username as sender_username, u.first_name as sender_first_name, u.last_name as sender_last_name, u.avatar_url as sender_avatar_url
FROM messages m
JOIN users u ON m.sender_id = u.id
WHERE m.project_id = $1 AND m.id > $2
ORDER BY m.created_at ASC
LIMIT $3
`

type ListMessagesByProjectAfterParams struct {
	ProjectID uuid.UUID `json:"projectId"`
	ID        uuid.UUID `json:"id"`
	Limit     int32     `json:"limit"`
}

type ListMessagesByProjectAfterRow struct {
	ID              uuid.UUID   `json:"id"`
	ProjectID       uuid.UUID   `json:"projectId"`
	SenderID        uuid.UUID   `json:"senderId"`
	Content         string      `json:"content"`
	MessageType     string      `json:"messageType"`
	ParentMessageID pgtype.UUID `json:"parentMessageId"`
	CreatedAt       time.Time   `json:"createdAt"`
	UpdatedAt       time.Time   `json:"updatedAt"`
	SenderUsername  string      `json:"senderUsername"`
	SenderFirstName string      `json:"senderFirstName"`
	SenderLastName  string      `json:"senderLastName"`
	SenderAvatarUrl *string     `json:"senderAvatarUrl"`
}

func (q *Queries) ListMessagesByProjectAfter(ctx context.Context, arg ListMessagesByProjectAfterParams) ([]ListMessagesByProjectAfterRow, error) {
	rows, err := q.db.Query(ctx, listMessagesByProjectAfter, arg.ProjectID, arg.ID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListMessagesByProjectAfterRow
	for rows.Next() {
		var i ListMessagesByProjectAfterRow
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.SenderID,
			&i.Content,
			&i.MessageType,
			&i.ParentMessageID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SenderUsername,
			&i.SenderFirstName,
			&i.SenderLastName,
			&i.SenderAvatarUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProjectInvites = `-- name: ListProjectInvites :many
SELECT id, project_id, created_by, invite_token, expires_at, max_uses, used_count, is_active, created_at, updated_at
FROM project_invites
WHERE project_id = $1 AND is_active = true
ORDER BY created_at DESC
`

func (q *Queries) ListProjectInvites(ctx context.Context, projectID uuid.UUID) ([]ProjectInvite, error) {
	rows, err := q.db.Query(ctx, listProjectInvites, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProjectInvite
	for rows.Next() {
		var i ProjectInvite
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.CreatedBy,
			&i.InviteToken,
			&i.ExpiresAt,
			&i.MaxUses,
			&i.UsedCount,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProjectMembers = `-- name: ListProjectMembers :many
SELECT u.id, u.username, u.email, u.first_name, u.last_name, u.avatar_url,
       pm.joined_at, pm.role
FROM project_members pm
JOIN users u ON pm.user_id = u.id
WHERE pm.project_id = $1
ORDER BY pm.joined_at
`

type ListProjectMembersRow struct {
	ID        uuid.UUID `json:"id"`
	Username  string    `json:"username"`
	Email     string    `json:"email"`
	FirstName string    `json:"firstName"`
	LastName  string    `json:"lastName"`
	AvatarUrl *string   `json:"avatarUrl"`
	JoinedAt  time.Time `json:"joinedAt"`
	Role      string    `json:"role"`
}

// Canonical model: project_members is single source of truth (includes owner)
func (q *Queries) ListProjectMembers(ctx context.Context, projectID uuid.UUID) ([]ListProjectMembersRow, error) {
	rows, err := q.db.Query(ctx, listProjectMembers, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListProjectMembersRow
	for rows.Next() {
		var i ListProjectMembersRow
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.Email,
			&i.FirstName,
			&i.LastName,
			&i.AvatarUrl,
			&i.JoinedAt,
			&i.Role,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProjectsByUser = `-- name: ListProjectsByUser :many
SELECT p.id, p.owner_id, p.name, p.description, p.created_at, p.updated_at,
       u.username AS owner_username,
       u.email AS owner_email,
       u.first_name AS owner_first_name,
       u.last_name AS owner_last_name,
       u.avatar_url AS owner_avatar_url
FROM projects p
JOIN users u ON u.id = p.owner_id
WHERE p.owner_id = $1
   OR EXISTS (
       SELECT 1
       FROM project_members pm
       WHERE pm.project_id = p.id AND pm.user_id = $1
   )
ORDER BY p.created_at DESC
LIMIT $2 OFFSET $3
`

type ListProjectsByUserParams struct {
	OwnerID uuid.UUID `json:"ownerId"`
	Limit   int32     `json:"limit"`
	Offset  int32     `json:"offset"`
}

type ListProjectsByUserRow struct {
	ID             uuid.UUID `json:"id"`
	OwnerID        uuid.UUID `json:"ownerId"`
	Name           string    `json:"name"`
	Description    *string   `json:"description"`
	CreatedAt      time.Time `json:"createdAt"`
	UpdatedAt      time.Time `json:"updatedAt"`
	OwnerUsername  string    `json:"ownerUsername"`
	OwnerEmail     string    `json:"ownerEmail"`
	OwnerFirstName string    `json:"ownerFirstName"`
	OwnerLastName  string    `json:"ownerLastName"`
	OwnerAvatarUrl *string   `json:"ownerAvatarUrl"`
}

// Fixed: Use EXISTS to avoid duplicates from LEFT JOIN
func (q *Queries) ListProjectsByUser(ctx context.Context, arg ListProjectsByUserParams) ([]ListProjectsByUserRow, error) {
	rows, err := q.db.Query(ctx, listProjectsByUser, arg.OwnerID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListProjectsByUserRow
	for rows.Next() {
		var i ListProjectsByUserRow
		if err := rows.Scan(
			&i.ID,
			&i.OwnerID,
			&i.Name,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.OwnerUsername,
			&i.OwnerEmail,
			&i.OwnerFirstName,
			&i.OwnerLastName,
			&i.OwnerAvatarUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSprintsByProject = `-- name: ListSprintsByProject :many
SELECT s.id, s.project_id, s.name, s.description, s.start_date, s.end_date, s.is_completed, s.is_started, s.created_at, s.updated_at,
       p.owner_id, u.username as owner_username, u.email as owner_email, u.first_name as owner_first_name, u.last_name as owner_last_name
FROM sprints s
JOIN projects p ON s.project_id = p.id
JOIN users u ON p.owner_id = u.id
WHERE s.project_id = $1
ORDER BY s.start_date DESC
LIMIT $2 OFFSET $3
`

type ListSprintsByProjectParams struct {
	ProjectID uuid.UUID `json:"projectId"`
	Limit     int32     `json:"limit"`
	Offset    int32     `json:"offset"`
}

type ListSprintsByProjectRow struct {
	ID             uuid.UUID `json:"id"`
	ProjectID      uuid.UUID `json:"projectId"`
	Name           string    `json:"name"`
	Description    *string   `json:"description"`
	StartDate      time.Time `json:"startDate"`
	EndDate        time.Time `json:"endDate"`
	IsCompleted    bool      `json:"isCompleted"`
	IsStarted      bool      `json:"isStarted"`
	CreatedAt      time.Time `json:"createdAt"`
	UpdatedAt      time.Time `json:"updatedAt"`
	OwnerID        uuid.UUID `json:"ownerId"`
	OwnerUsername  string    `json:"ownerUsername"`
	OwnerEmail     string    `json:"ownerEmail"`
	OwnerFirstName string    `json:"ownerFirstName"`
	OwnerLastName  string    `json:"ownerLastName"`
}

func (q *Queries) ListSprintsByProject(ctx context.Context, arg ListSprintsByProjectParams) ([]ListSprintsByProjectRow, error) {
	rows, err := q.db.Query(ctx, listSprintsByProject, arg.ProjectID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListSprintsByProjectRow
	for rows.Next() {
		var i ListSprintsByProjectRow
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.Name,
			&i.Description,
			&i.StartDate,
			&i.EndDate,
			&i.IsCompleted,
			&i.IsStarted,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.OwnerID,
			&i.OwnerUsername,
			&i.OwnerEmail,
			&i.OwnerFirstName,
			&i.OwnerLastName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTasksByProject = `-- name: ListTasksByProject :many
SELECT t.id, t.project_id, t.sprint_id, t.assignee_id, t.description, t.status, t.created_at, t.updated_at,
       u.username as assignee_username, u.first_name as assignee_first_name, u.last_name as assignee_last_name,
       p.owner_id, owner.username as owner_username, owner.email as owner_email, owner.first_name as owner_first_name, owner.last_name as owner_last_name
FROM tasks t
LEFT JOIN users u ON t.assignee_id = u.id
JOIN projects p ON t.project_id = p.id
JOIN users owner ON p.owner_id = owner.id
WHERE t.project_id = $1
ORDER BY t.created_at DESC
LIMIT $2 OFFSET $3
`

type ListTasksByProjectParams struct {
	ProjectID uuid.UUID `json:"projectId"`
	Limit     int32     `json:"limit"`
	Offset    int32     `json:"offset"`
}

type ListTasksByProjectRow struct {
	ID                uuid.UUID   `json:"id"`
	ProjectID         uuid.UUID   `json:"projectId"`
	SprintID          pgtype.UUID `json:"sprintId"`
	AssigneeID        pgtype.UUID `json:"assigneeId"`
	Description       *string     `json:"description"`
	Status            int32       `json:"status"`
	CreatedAt         time.Time   `json:"createdAt"`
	UpdatedAt         time.Time   `json:"updatedAt"`
	AssigneeUsername  *string     `json:"assigneeUsername"`
	AssigneeFirstName *string     `json:"assigneeFirstName"`
	AssigneeLastName  *string     `json:"assigneeLastName"`
	OwnerID           uuid.UUID   `json:"ownerId"`
	OwnerUsername     string      `json:"ownerUsername"`
	OwnerEmail        string      `json:"ownerEmail"`
	OwnerFirstName    string      `json:"ownerFirstName"`
	OwnerLastName     string      `json:"ownerLastName"`
}

func (q *Queries) ListTasksByProject(ctx context.Context, arg ListTasksByProjectParams) ([]ListTasksByProjectRow, error) {
	rows, err := q.db.Query(ctx, listTasksByProject, arg.ProjectID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListTasksByProjectRow
	for rows.Next() {
		var i ListTasksByProjectRow
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.SprintID,
			&i.AssigneeID,
			&i.Description,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.AssigneeUsername,
			&i.AssigneeFirstName,
			&i.AssigneeLastName,
			&i.OwnerID,
			&i.OwnerUsername,
			&i.OwnerEmail,
			&i.OwnerFirstName,
			&i.OwnerLastName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTasksBySprint = `-- name: ListTasksBySprint :many
SELECT t.id, t.project_id, t.sprint_id, t.assignee_id, t.description, t.status, t.created_at, t.updated_at,
       u.username as assignee_username, u.first_name as assignee_first_name, u.last_name as assignee_last_name,
       p.owner_id, owner.username as owner_username, owner.email as owner_email, owner.first_name as owner_first_name, owner.last_name as owner_last_name
FROM tasks t
LEFT JOIN users u ON t.assignee_id = u.id
JOIN projects p ON t.project_id = p.id
JOIN users owner ON p.owner_id = owner.id
WHERE t.sprint_id = $1
ORDER BY t.created_at DESC
LIMIT $2 OFFSET $3
`

type ListTasksBySprintParams struct {
	SprintID pgtype.UUID `json:"sprintId"`
	Limit    int32       `json:"limit"`
	Offset   int32       `json:"offset"`
}

type ListTasksBySprintRow struct {
	ID                uuid.UUID   `json:"id"`
	ProjectID         uuid.UUID   `json:"projectId"`
	SprintID          pgtype.UUID `json:"sprintId"`
	AssigneeID        pgtype.UUID `json:"assigneeId"`
	Description       *string     `json:"description"`
	Status            int32       `json:"status"`
	CreatedAt         time.Time   `json:"createdAt"`
	UpdatedAt         time.Time   `json:"updatedAt"`
	AssigneeUsername  *string     `json:"assigneeUsername"`
	AssigneeFirstName *string     `json:"assigneeFirstName"`
	AssigneeLastName  *string     `json:"assigneeLastName"`
	OwnerID           uuid.UUID   `json:"ownerId"`
	OwnerUsername     string      `json:"ownerUsername"`
	OwnerEmail        string      `json:"ownerEmail"`
	OwnerFirstName    string      `json:"ownerFirstName"`
	OwnerLastName     string      `json:"ownerLastName"`
}

func (q *Queries) ListTasksBySprint(ctx context.Context, arg ListTasksBySprintParams) ([]ListTasksBySprintRow, error) {
	rows, err := q.db.Query(ctx, listTasksBySprint, arg.SprintID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListTasksBySprintRow
	for rows.Next() {
		var i ListTasksBySprintRow
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.SprintID,
			&i.AssigneeID,
			&i.Description,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.AssigneeUsername,
			&i.AssigneeFirstName,
			&i.AssigneeLastName,
			&i.OwnerID,
			&i.OwnerUsername,
			&i.OwnerEmail,
			&i.OwnerFirstName,
			&i.OwnerLastName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUsers = `-- name: ListUsers :many
SELECT id, username, email, first_name, last_name, active, avatar_url, created_at, updated_at
FROM users
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type ListUsersParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListUsersRow struct {
	ID        uuid.UUID `json:"id"`
	Username  string    `json:"username"`
	Email     string    `json:"email"`
	FirstName string    `json:"firstName"`
	LastName  string    `json:"lastName"`
	Active    bool      `json:"active"`
	AvatarUrl *string   `json:"avatarUrl"`
	CreatedAt time.Time `json:"createdAt"`
	UpdatedAt time.Time `json:"updatedAt"`
}

func (q *Queries) ListUsers(ctx context.Context, arg ListUsersParams) ([]ListUsersRow, error) {
	rows, err := q.db.Query(ctx, listUsers, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListUsersRow
	for rows.Next() {
		var i ListUsersRow
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.Email,
			&i.FirstName,
			&i.LastName,
			&i.Active,
			&i.AvatarUrl,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const projectExists = `-- name: ProjectExists :one
SELECT EXISTS(
    SELECT 1 FROM projects p
    WHERE p.id = $1
) as exists
`

func (q *Queries) ProjectExists(ctx context.Context, id uuid.UUID) (bool, error) {
	row := q.db.QueryRow(ctx, projectExists, id)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const removeProjectMember = `-- name: RemoveProjectMember :exec
DELETE FROM project_members WHERE project_id = $1 AND user_id = $2
`

type RemoveProjectMemberParams struct {
	ProjectID uuid.UUID `json:"projectId"`
	UserID    uuid.UUID `json:"userId"`
}

func (q *Queries) RemoveProjectMember(ctx context.Context, arg RemoveProjectMemberParams) error {
	_, err := q.db.Exec(ctx, removeProjectMember, arg.ProjectID, arg.UserID)
	return err
}

const updateMessage = `-- name: UpdateMessage :one
UPDATE messages
SET content = $2, updated_at = now()
WHERE id = $1
RETURNING id, project_id, sender_id, content, message_type, parent_message_id, created_at, updated_at
`

type UpdateMessageParams struct {
	ID      uuid.UUID `json:"id"`
	Content string    `json:"content"`
}

func (q *Queries) UpdateMessage(ctx context.Context, arg UpdateMessageParams) (Message, error) {
	row := q.db.QueryRow(ctx, updateMessage, arg.ID, arg.Content)
	var i Message
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.SenderID,
		&i.Content,
		&i.MessageType,
		&i.ParentMessageID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateProject = `-- name: UpdateProject :one
UPDATE projects
SET name = $2, description = $3, updated_at = now()
WHERE id = $1
RETURNING id, owner_id, name, description, created_at, updated_at
`

type UpdateProjectParams struct {
	ID          uuid.UUID `json:"id"`
	Name        string    `json:"name"`
	Description *string   `json:"description"`
}

func (q *Queries) UpdateProject(ctx context.Context, arg UpdateProjectParams) (Project, error) {
	row := q.db.QueryRow(ctx, updateProject, arg.ID, arg.Name, arg.Description)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.OwnerID,
		&i.Name,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateRefreshTokenGoogleTokens = `-- name: UpdateRefreshTokenGoogleTokens :exec
UPDATE refresh_tokens
SET google_access_token = $2, google_token_expiry = $3
WHERE token = $1
`

type UpdateRefreshTokenGoogleTokensParams struct {
	Token             string             `json:"token"`
	GoogleAccessToken *string            `json:"googleAccessToken"`
	GoogleTokenExpiry pgtype.Timestamptz `json:"googleTokenExpiry"`
}

func (q *Queries) UpdateRefreshTokenGoogleTokens(ctx context.Context, arg UpdateRefreshTokenGoogleTokensParams) error {
	_, err := q.db.Exec(ctx, updateRefreshTokenGoogleTokens, arg.Token, arg.GoogleAccessToken, arg.GoogleTokenExpiry)
	return err
}

const updateSprint = `-- name: UpdateSprint :one
UPDATE sprints
SET name = $2, description = $3, start_date = $4, end_date = $5, updated_at = now()
WHERE id = $1
RETURNING id, project_id, name, description, start_date, end_date, is_completed, is_started, created_at, updated_at
`

type UpdateSprintParams struct {
	ID          uuid.UUID `json:"id"`
	Name        string    `json:"name"`
	Description *string   `json:"description"`
	StartDate   time.Time `json:"startDate"`
	EndDate     time.Time `json:"endDate"`
}

func (q *Queries) UpdateSprint(ctx context.Context, arg UpdateSprintParams) (Sprint, error) {
	row := q.db.QueryRow(ctx, updateSprint,
		arg.ID,
		arg.Name,
		arg.Description,
		arg.StartDate,
		arg.EndDate,
	)
	var i Sprint
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.Name,
		&i.Description,
		&i.StartDate,
		&i.EndDate,
		&i.IsCompleted,
		&i.IsStarted,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateSprintStatus = `-- name: UpdateSprintStatus :one
UPDATE sprints
SET is_started = $2, is_completed = $3, updated_at = now()
WHERE id = $1
RETURNING id, project_id, name, description, start_date, end_date, is_completed, is_started, created_at, updated_at
`

type UpdateSprintStatusParams struct {
	ID          uuid.UUID `json:"id"`
	IsStarted   bool      `json:"isStarted"`
	IsCompleted bool      `json:"isCompleted"`
}

func (q *Queries) UpdateSprintStatus(ctx context.Context, arg UpdateSprintStatusParams) (Sprint, error) {
	row := q.db.QueryRow(ctx, updateSprintStatus, arg.ID, arg.IsStarted, arg.IsCompleted)
	var i Sprint
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.Name,
		&i.Description,
		&i.StartDate,
		&i.EndDate,
		&i.IsCompleted,
		&i.IsStarted,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateTask = `-- name: UpdateTask :one
UPDATE tasks
SET description = $2, assignee_id = $3, updated_at = now()
WHERE id = $1
RETURNING id, project_id, sprint_id, assignee_id, description, status, created_at, updated_at
`

type UpdateTaskParams struct {
	ID          uuid.UUID   `json:"id"`
	Description *string     `json:"description"`
	AssigneeID  pgtype.UUID `json:"assigneeId"`
}

type UpdateTaskRow struct {
	ID          uuid.UUID   `json:"id"`
	ProjectID   uuid.UUID   `json:"projectId"`
	SprintID    pgtype.UUID `json:"sprintId"`
	AssigneeID  pgtype.UUID `json:"assigneeId"`
	Description *string     `json:"description"`
	Status      int32       `json:"status"`
	CreatedAt   time.Time   `json:"createdAt"`
	UpdatedAt   time.Time   `json:"updatedAt"`
}

func (q *Queries) UpdateTask(ctx context.Context, arg UpdateTaskParams) (UpdateTaskRow, error) {
	row := q.db.QueryRow(ctx, updateTask, arg.ID, arg.Description, arg.AssigneeID)
	var i UpdateTaskRow
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.SprintID,
		&i.AssigneeID,
		&i.Description,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateTaskStatus = `-- name: UpdateTaskStatus :one
UPDATE tasks
SET status = $2, updated_at = now()
WHERE id = $1
RETURNING id, project_id, sprint_id, assignee_id, description, status, created_at, updated_at
`

type UpdateTaskStatusParams struct {
	ID     uuid.UUID `json:"id"`
	Status int32     `json:"status"`
}

type UpdateTaskStatusRow struct {
	ID          uuid.UUID   `json:"id"`
	ProjectID   uuid.UUID   `json:"projectId"`
	SprintID    pgtype.UUID `json:"sprintId"`
	AssigneeID  pgtype.UUID `json:"assigneeId"`
	Description *string     `json:"description"`
	Status      int32       `json:"status"`
	CreatedAt   time.Time   `json:"createdAt"`
	UpdatedAt   time.Time   `json:"updatedAt"`
}

func (q *Queries) UpdateTaskStatus(ctx context.Context, arg UpdateTaskStatusParams) (UpdateTaskStatusRow, error) {
	row := q.db.QueryRow(ctx, updateTaskStatus, arg.ID, arg.Status)
	var i UpdateTaskStatusRow
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.SprintID,
		&i.AssigneeID,
		&i.Description,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateUser = `-- name: UpdateUser :one
UPDATE users
SET username = $2, email = $3, first_name = $4, last_name = $5, avatar_url = $6, updated_at = now()
WHERE id = $1
RETURNING id, username, email, first_name, last_name, active, avatar_url, created_at, updated_at
`

type UpdateUserParams struct {
	ID        uuid.UUID `json:"id"`
	Username  string    `json:"username"`
	Email     string    `json:"email"`
	FirstName string    `json:"firstName"`
	LastName  string    `json:"lastName"`
	AvatarUrl *string   `json:"avatarUrl"`
}

type UpdateUserRow struct {
	ID        uuid.UUID `json:"id"`
	Username  string    `json:"username"`
	Email     string    `json:"email"`
	FirstName string    `json:"firstName"`
	LastName  string    `json:"lastName"`
	Active    bool      `json:"active"`
	AvatarUrl *string   `json:"avatarUrl"`
	CreatedAt time.Time `json:"createdAt"`
	UpdatedAt time.Time `json:"updatedAt"`
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) (UpdateUserRow, error) {
	row := q.db.QueryRow(ctx, updateUser,
		arg.ID,
		arg.Username,
		arg.Email,
		arg.FirstName,
		arg.LastName,
		arg.AvatarUrl,
	)
	var i UpdateUserRow
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.FirstName,
		&i.LastName,
		&i.Active,
		&i.AvatarUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateUserPassword = `-- name: UpdateUserPassword :exec
UPDATE users
SET password_h = $2, updated_at = now()
WHERE id = $1
`

type UpdateUserPasswordParams struct {
	ID        uuid.UUID `json:"id"`
	PasswordH *string   `json:"passwordH"`
}

func (q *Queries) UpdateUserPassword(ctx context.Context, arg UpdateUserPasswordParams) error {
	_, err := q.db.Exec(ctx, updateUserPassword, arg.ID, arg.PasswordH)
	return err
}

const updateUserProfilePicture = `-- name: UpdateUserProfilePicture :exec
UPDATE users
SET profile_picture_url = $2, updated_at = now()
WHERE id = $1
`

type UpdateUserProfilePictureParams struct {
	ID                uuid.UUID `json:"id"`
	ProfilePictureUrl *string   `json:"profilePictureUrl"`
}

func (q *Queries) UpdateUserProfilePicture(ctx context.Context, arg UpdateUserProfilePictureParams) error {
	_, err := q.db.Exec(ctx, updateUserProfilePicture, arg.ID, arg.ProfilePictureUrl)
	return err
}
